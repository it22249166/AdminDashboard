{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { getPtg } from './useSizes';\n/**\n * Handle user drag resize logic.\n */\n\nexport default function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, isRTL) {\n  const limitSizes = items.map(item => [item.min, item.max]);\n  const mergedContainerSize = containerSize || 0;\n\n  const ptg2px = ptg => ptg * mergedContainerSize; // ======================== Resize ========================\n\n\n  function getLimitSize(str, defaultLimit) {\n    if (typeof str === 'string') {\n      return ptg2px(getPtg(str));\n    }\n\n    return str !== null && str !== void 0 ? str : defaultLimit;\n  } // Real px sizes\n\n\n  const [cacheSizes, setCacheSizes] = React.useState([]);\n  const cacheCollapsedSize = React.useRef([]);\n  /**\n   * When start drag, check the direct is `start` or `end`.\n   * This will handle when 2 splitter bar are in the same position.\n   */\n\n  const [movingIndex, setMovingIndex] = React.useState(null);\n\n  const getPxSizes = () => percentSizes.map(ptg2px);\n\n  const onOffsetStart = index => {\n    setCacheSizes(getPxSizes());\n    setMovingIndex({\n      index,\n      confirmed: false\n    });\n  };\n\n  const onOffsetUpdate = (index, offset) => {\n    var _a; // First time trigger move index update is not sync in the state\n\n\n    let confirmedIndex = null; // We need to know what the real index is.\n\n    if ((!movingIndex || !movingIndex.confirmed) && offset !== 0) {\n      // Search for the real index\n      if (offset > 0) {\n        confirmedIndex = index;\n        setMovingIndex({\n          index,\n          confirmed: true\n        });\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {\n            confirmedIndex = i;\n            setMovingIndex({\n              index: i,\n              confirmed: true\n            });\n            break;\n          }\n        }\n      }\n    }\n\n    const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index;\n\n    const numSizes = _toConsumableArray(cacheSizes);\n\n    const nextIndex = mergedIndex + 1; // Get boundary\n\n    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);\n    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);\n    let mergedOffset = offset; // Align with the boundary\n\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    } // Do offset\n\n\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    updateSizes(numSizes);\n    return numSizes;\n  };\n\n  const onOffsetEnd = () => {\n    setMovingIndex(null);\n  }; // ======================= Collapse =======================\n\n\n  const onCollapse = (index, type) => {\n    const currentSizes = getPxSizes();\n    const adjustedType = isRTL ? type === 'start' ? 'end' : 'start' : type;\n    const currentIndex = adjustedType === 'start' ? index : index + 1;\n    const targetIndex = adjustedType === 'start' ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n\n    if (currentSize !== 0 && targetSize !== 0) {\n      // Collapse directly\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize.current[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);\n      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);\n      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);\n      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);\n      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);\n      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);\n      const halfOffset = (limitEnd - limitStart) / 2;\n      const targetCacheCollapsedSize = cacheCollapsedSize.current[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;\n\n      if (shouldUseCache) {\n        currentSizes[targetIndex] = targetCacheCollapsedSize;\n        currentSizes[currentIndex] = currentCacheCollapsedSize;\n      } else {\n        currentSizes[currentIndex] -= halfOffset;\n        currentSizes[targetIndex] += halfOffset;\n      }\n    }\n\n    updateSizes(currentSizes);\n    return currentSizes;\n  };\n\n  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];\n}","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/splitter/hooks/useResize.js"],"names":["_toConsumableArray","React","getPtg","useResize","items","resizableInfos","percentSizes","containerSize","updateSizes","isRTL","limitSizes","map","item","min","max","mergedContainerSize","ptg2px","ptg","getLimitSize","str","defaultLimit","cacheSizes","setCacheSizes","useState","cacheCollapsedSize","useRef","movingIndex","setMovingIndex","getPxSizes","onOffsetStart","index","confirmed","onOffsetUpdate","offset","_a","confirmedIndex","i","resizable","mergedIndex","numSizes","nextIndex","startMinSize","endMinSize","startMaxSize","endMaxSize","mergedOffset","onOffsetEnd","onCollapse","type","currentSizes","adjustedType","currentIndex","targetIndex","currentSize","targetSize","current","totalSize","currentSizeMin","currentSizeMax","targetSizeMin","targetSizeMax","limitStart","Math","limitEnd","halfOffset","targetCacheCollapsedSize","currentCacheCollapsedSize","shouldUseCache"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { getPtg } from './useSizes';\n/**\n * Handle user drag resize logic.\n */\nexport default function useResize(items, resizableInfos, percentSizes, containerSize, updateSizes, isRTL) {\n  const limitSizes = items.map(item => [item.min, item.max]);\n  const mergedContainerSize = containerSize || 0;\n  const ptg2px = ptg => ptg * mergedContainerSize;\n  // ======================== Resize ========================\n  function getLimitSize(str, defaultLimit) {\n    if (typeof str === 'string') {\n      return ptg2px(getPtg(str));\n    }\n    return str !== null && str !== void 0 ? str : defaultLimit;\n  }\n  // Real px sizes\n  const [cacheSizes, setCacheSizes] = React.useState([]);\n  const cacheCollapsedSize = React.useRef([]);\n  /**\n   * When start drag, check the direct is `start` or `end`.\n   * This will handle when 2 splitter bar are in the same position.\n   */\n  const [movingIndex, setMovingIndex] = React.useState(null);\n  const getPxSizes = () => percentSizes.map(ptg2px);\n  const onOffsetStart = index => {\n    setCacheSizes(getPxSizes());\n    setMovingIndex({\n      index,\n      confirmed: false\n    });\n  };\n  const onOffsetUpdate = (index, offset) => {\n    var _a;\n    // First time trigger move index update is not sync in the state\n    let confirmedIndex = null;\n    // We need to know what the real index is.\n    if ((!movingIndex || !movingIndex.confirmed) && offset !== 0) {\n      // Search for the real index\n      if (offset > 0) {\n        confirmedIndex = index;\n        setMovingIndex({\n          index,\n          confirmed: true\n        });\n      } else {\n        for (let i = index; i >= 0; i -= 1) {\n          if (cacheSizes[i] > 0 && resizableInfos[i].resizable) {\n            confirmedIndex = i;\n            setMovingIndex({\n              index: i,\n              confirmed: true\n            });\n            break;\n          }\n        }\n      }\n    }\n    const mergedIndex = (_a = confirmedIndex !== null && confirmedIndex !== void 0 ? confirmedIndex : movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index) !== null && _a !== void 0 ? _a : index;\n    const numSizes = _toConsumableArray(cacheSizes);\n    const nextIndex = mergedIndex + 1;\n    // Get boundary\n    const startMinSize = getLimitSize(limitSizes[mergedIndex][0], 0);\n    const endMinSize = getLimitSize(limitSizes[nextIndex][0], 0);\n    const startMaxSize = getLimitSize(limitSizes[mergedIndex][1], mergedContainerSize);\n    const endMaxSize = getLimitSize(limitSizes[nextIndex][1], mergedContainerSize);\n    let mergedOffset = offset;\n    // Align with the boundary\n    if (numSizes[mergedIndex] + mergedOffset < startMinSize) {\n      mergedOffset = startMinSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset < endMinSize) {\n      mergedOffset = numSizes[nextIndex] - endMinSize;\n    }\n    if (numSizes[mergedIndex] + mergedOffset > startMaxSize) {\n      mergedOffset = startMaxSize - numSizes[mergedIndex];\n    }\n    if (numSizes[nextIndex] - mergedOffset > endMaxSize) {\n      mergedOffset = numSizes[nextIndex] - endMaxSize;\n    }\n    // Do offset\n    numSizes[mergedIndex] += mergedOffset;\n    numSizes[nextIndex] -= mergedOffset;\n    updateSizes(numSizes);\n    return numSizes;\n  };\n  const onOffsetEnd = () => {\n    setMovingIndex(null);\n  };\n  // ======================= Collapse =======================\n  const onCollapse = (index, type) => {\n    const currentSizes = getPxSizes();\n    const adjustedType = isRTL ? type === 'start' ? 'end' : 'start' : type;\n    const currentIndex = adjustedType === 'start' ? index : index + 1;\n    const targetIndex = adjustedType === 'start' ? index + 1 : index;\n    const currentSize = currentSizes[currentIndex];\n    const targetSize = currentSizes[targetIndex];\n    if (currentSize !== 0 && targetSize !== 0) {\n      // Collapse directly\n      currentSizes[currentIndex] = 0;\n      currentSizes[targetIndex] += currentSize;\n      cacheCollapsedSize.current[index] = currentSize;\n    } else {\n      const totalSize = currentSize + targetSize;\n      const currentSizeMin = getLimitSize(limitSizes[currentIndex][0], 0);\n      const currentSizeMax = getLimitSize(limitSizes[currentIndex][1], mergedContainerSize);\n      const targetSizeMin = getLimitSize(limitSizes[targetIndex][0], 0);\n      const targetSizeMax = getLimitSize(limitSizes[targetIndex][1], mergedContainerSize);\n      const limitStart = Math.max(currentSizeMin, totalSize - targetSizeMax);\n      const limitEnd = Math.min(currentSizeMax, totalSize - targetSizeMin);\n      const halfOffset = (limitEnd - limitStart) / 2;\n      const targetCacheCollapsedSize = cacheCollapsedSize.current[index];\n      const currentCacheCollapsedSize = totalSize - targetCacheCollapsedSize;\n      const shouldUseCache = targetCacheCollapsedSize && targetCacheCollapsedSize <= targetSizeMax && targetCacheCollapsedSize >= targetSizeMin && currentCacheCollapsedSize <= currentSizeMax && currentCacheCollapsedSize >= currentSizeMin;\n      if (shouldUseCache) {\n        currentSizes[targetIndex] = targetCacheCollapsedSize;\n        currentSizes[currentIndex] = currentCacheCollapsedSize;\n      } else {\n        currentSizes[currentIndex] -= halfOffset;\n        currentSizes[targetIndex] += halfOffset;\n      }\n    }\n    updateSizes(currentSizes);\n    return currentSizes;\n  };\n  return [onOffsetStart, onOffsetUpdate, onOffsetEnd, onCollapse, movingIndex === null || movingIndex === void 0 ? void 0 : movingIndex.index];\n}"]},"metadata":{},"sourceType":"module"}