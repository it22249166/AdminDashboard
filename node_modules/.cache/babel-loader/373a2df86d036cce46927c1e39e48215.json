{"ast":null,"code":"\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { AggregationColor } from '../../color';\nimport { getGradientPercentColor } from '../../util';\nimport { GradientColorSlider } from '../ColorSlider';\n\nfunction sortColors(colors) {\n  return _toConsumableArray(colors).sort((a, b) => a.percent - b.percent);\n}\n/**\n * GradientColorBar will auto show when the mode is `gradient`.\n */\n\n\nconst GradientColorBar = props => {\n  const {\n    prefixCls,\n    mode,\n    onChange,\n    onChangeComplete,\n    onActive,\n    activeIndex,\n    onGradientDragging,\n    colors\n  } = props;\n  const isGradient = mode === 'gradient'; // ============================= Colors =============================\n\n  const colorList = React.useMemo(() => colors.map(info => ({\n    percent: info.percent,\n    color: info.color.toRgbString()\n  })), [colors]);\n  const values = React.useMemo(() => colorList.map(info => info.percent), [colorList]); // ============================== Drag ==============================\n\n  const colorsRef = React.useRef(colorList); // Record current colors\n\n  const onDragStart = _ref => {\n    let {\n      rawValues,\n      draggingIndex,\n      draggingValue\n    } = _ref;\n\n    if (rawValues.length > colorList.length) {\n      // Add new node\n      const newPointColor = getGradientPercentColor(colorList, draggingValue);\n\n      const nextColors = _toConsumableArray(colorList);\n\n      nextColors.splice(draggingIndex, 0, {\n        percent: draggingValue,\n        color: newPointColor\n      });\n      colorsRef.current = nextColors;\n    } else {\n      colorsRef.current = colorList;\n    }\n\n    onGradientDragging(true);\n    onChange(new AggregationColor(sortColors(colorsRef.current)), true);\n  }; // Adjust color when dragging\n\n\n  const onDragChange = _ref2 => {\n    let {\n      deleteIndex,\n      draggingIndex,\n      draggingValue\n    } = _ref2;\n\n    let nextColors = _toConsumableArray(colorsRef.current);\n\n    if (deleteIndex !== -1) {\n      nextColors.splice(deleteIndex, 1);\n    } else {\n      nextColors[draggingIndex] = Object.assign(Object.assign({}, nextColors[draggingIndex]), {\n        percent: draggingValue\n      });\n      nextColors = sortColors(nextColors);\n    }\n\n    onChange(new AggregationColor(nextColors), true);\n  }; // ============================== Key ===============================\n\n\n  const onKeyDelete = index => {\n    const nextColors = _toConsumableArray(colorList);\n\n    nextColors.splice(index, 1);\n    const nextColor = new AggregationColor(nextColors);\n    onChange(nextColor);\n    onChangeComplete(nextColor);\n  }; // ============================= Change =============================\n\n\n  const onInternalChangeComplete = nextValues => {\n    onChangeComplete(new AggregationColor(colorList)); // Reset `activeIndex` if out of range\n\n    if (activeIndex >= nextValues.length) {\n      onActive(nextValues.length - 1);\n    }\n\n    onGradientDragging(false);\n  }; // ============================= Render =============================\n\n\n  if (!isGradient) {\n    return null;\n  }\n\n  return /*#__PURE__*/React.createElement(GradientColorSlider, {\n    min: 0,\n    max: 100,\n    prefixCls: prefixCls,\n    className: `${prefixCls}-gradient-slider`,\n    colors: colorList,\n    color: null,\n    value: values,\n    range: true,\n    onChangeComplete: onInternalChangeComplete,\n    disabled: false,\n    type: \"gradient\",\n    // Active\n    activeIndex: activeIndex,\n    onActive: onActive,\n    // Drag\n    onDragStart: onDragStart,\n    onDragChange: onDragChange,\n    onKeyDelete: onKeyDelete\n  });\n};\n\nexport default /*#__PURE__*/React.memo(GradientColorBar);","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/color-picker/components/PanelPicker/GradientColorBar.js"],"names":["_toConsumableArray","React","AggregationColor","getGradientPercentColor","GradientColorSlider","sortColors","colors","sort","a","b","percent","GradientColorBar","props","prefixCls","mode","onChange","onChangeComplete","onActive","activeIndex","onGradientDragging","isGradient","colorList","useMemo","map","info","color","toRgbString","values","colorsRef","useRef","onDragStart","_ref","rawValues","draggingIndex","draggingValue","length","newPointColor","nextColors","splice","current","onDragChange","_ref2","deleteIndex","Object","assign","onKeyDelete","index","nextColor","onInternalChangeComplete","nextValues","createElement","min","max","className","value","range","disabled","type","memo"],"mappings":"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","sourcesContent":["\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport * as React from 'react';\nimport { AggregationColor } from '../../color';\nimport { getGradientPercentColor } from '../../util';\nimport { GradientColorSlider } from '../ColorSlider';\nfunction sortColors(colors) {\n  return _toConsumableArray(colors).sort((a, b) => a.percent - b.percent);\n}\n/**\n * GradientColorBar will auto show when the mode is `gradient`.\n */\nconst GradientColorBar = props => {\n  const {\n    prefixCls,\n    mode,\n    onChange,\n    onChangeComplete,\n    onActive,\n    activeIndex,\n    onGradientDragging,\n    colors\n  } = props;\n  const isGradient = mode === 'gradient';\n  // ============================= Colors =============================\n  const colorList = React.useMemo(() => colors.map(info => ({\n    percent: info.percent,\n    color: info.color.toRgbString()\n  })), [colors]);\n  const values = React.useMemo(() => colorList.map(info => info.percent), [colorList]);\n  // ============================== Drag ==============================\n  const colorsRef = React.useRef(colorList);\n  // Record current colors\n  const onDragStart = _ref => {\n    let {\n      rawValues,\n      draggingIndex,\n      draggingValue\n    } = _ref;\n    if (rawValues.length > colorList.length) {\n      // Add new node\n      const newPointColor = getGradientPercentColor(colorList, draggingValue);\n      const nextColors = _toConsumableArray(colorList);\n      nextColors.splice(draggingIndex, 0, {\n        percent: draggingValue,\n        color: newPointColor\n      });\n      colorsRef.current = nextColors;\n    } else {\n      colorsRef.current = colorList;\n    }\n    onGradientDragging(true);\n    onChange(new AggregationColor(sortColors(colorsRef.current)), true);\n  };\n  // Adjust color when dragging\n  const onDragChange = _ref2 => {\n    let {\n      deleteIndex,\n      draggingIndex,\n      draggingValue\n    } = _ref2;\n    let nextColors = _toConsumableArray(colorsRef.current);\n    if (deleteIndex !== -1) {\n      nextColors.splice(deleteIndex, 1);\n    } else {\n      nextColors[draggingIndex] = Object.assign(Object.assign({}, nextColors[draggingIndex]), {\n        percent: draggingValue\n      });\n      nextColors = sortColors(nextColors);\n    }\n    onChange(new AggregationColor(nextColors), true);\n  };\n  // ============================== Key ===============================\n  const onKeyDelete = index => {\n    const nextColors = _toConsumableArray(colorList);\n    nextColors.splice(index, 1);\n    const nextColor = new AggregationColor(nextColors);\n    onChange(nextColor);\n    onChangeComplete(nextColor);\n  };\n  // ============================= Change =============================\n  const onInternalChangeComplete = nextValues => {\n    onChangeComplete(new AggregationColor(colorList));\n    // Reset `activeIndex` if out of range\n    if (activeIndex >= nextValues.length) {\n      onActive(nextValues.length - 1);\n    }\n    onGradientDragging(false);\n  };\n  // ============================= Render =============================\n  if (!isGradient) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(GradientColorSlider, {\n    min: 0,\n    max: 100,\n    prefixCls: prefixCls,\n    className: `${prefixCls}-gradient-slider`,\n    colors: colorList,\n    color: null,\n    value: values,\n    range: true,\n    onChangeComplete: onInternalChangeComplete,\n    disabled: false,\n    type: \"gradient\",\n    // Active\n    activeIndex: activeIndex,\n    onActive: onActive,\n    // Drag\n    onDragStart: onDragStart,\n    onDragChange: onDragChange,\n    onKeyDelete: onKeyDelete\n  });\n};\nexport default /*#__PURE__*/React.memo(GradientColorBar);"]},"metadata":{},"sourceType":"module"}