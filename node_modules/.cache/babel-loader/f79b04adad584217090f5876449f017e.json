{"ast":null,"code":"import * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\n\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      return Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    var _a;\n\n    const leftData = [];\n    const rightData = Array.from({\n      length: (_a = targetKeys === null || targetKeys === void 0 ? void 0 : targetKeys.length) !== null && _a !== void 0 ? _a : 0\n    });\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        const idx = targetKeysMap.get(record.key);\n        rightData[idx] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys]);\n  return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];\n};\n\nexport default useData;","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/transfer/hooks/useData.js"],"names":["React","groupKeysMap","useData","dataSource","rowKey","targetKeys","mergedDataSource","useMemo","map","record","Object","assign","key","leftDataSource","rightDataSource","_a","leftData","rightData","Array","from","length","targetKeysMap","forEach","has","idx","get","push","filter","Boolean"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,YAAT,QAA6B,uBAA7B;;AACA,MAAMC,OAAO,GAAG,CAACC,UAAD,EAAaC,MAAb,EAAqBC,UAArB,KAAoC;AAClD,QAAMC,gBAAgB,GAAGN,KAAK,CAACO,OAAN,CAAc,MAAM,CAACJ,UAAU,IAAI,EAAf,EAAmBK,GAAnB,CAAuBC,MAAM,IAAI;AAC5E,QAAIL,MAAJ,EAAY;AACV,aAAOM,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBF,MAAlB,CAAd,EAAyC;AAC9CG,QAAAA,GAAG,EAAER,MAAM,CAACK,MAAD;AADmC,OAAzC,CAAP;AAGD;;AACD,WAAOA,MAAP;AACD,GAP4C,CAApB,EAOrB,CAACN,UAAD,EAAaC,MAAb,CAPqB,CAAzB;AAQA,QAAM,CAACS,cAAD,EAAiBC,eAAjB,IAAoCd,KAAK,CAACO,OAAN,CAAc,MAAM;AAC5D,QAAIQ,EAAJ;;AACA,UAAMC,QAAQ,GAAG,EAAjB;AACA,UAAMC,SAAS,GAAGC,KAAK,CAACC,IAAN,CAAW;AAC3BC,MAAAA,MAAM,EAAE,CAACL,EAAE,GAAGV,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,CAACe,MAAzE,MAAqF,IAArF,IAA6FL,EAAE,KAAK,KAAK,CAAzG,GAA6GA,EAA7G,GAAkH;AAD/F,KAAX,CAAlB;AAGA,UAAMM,aAAa,GAAGpB,YAAY,CAACI,UAAU,IAAI,EAAf,CAAlC;AACAC,IAAAA,gBAAgB,CAACgB,OAAjB,CAAyBb,MAAM,IAAI;AACjC;AACA;AACA,UAAIY,aAAa,CAACE,GAAd,CAAkBd,MAAM,CAACG,GAAzB,CAAJ,EAAmC;AACjC,cAAMY,GAAG,GAAGH,aAAa,CAACI,GAAd,CAAkBhB,MAAM,CAACG,GAAzB,CAAZ;AACAK,QAAAA,SAAS,CAACO,GAAD,CAAT,GAAiBf,MAAjB;AACD,OAHD,MAGO;AACLO,QAAAA,QAAQ,CAACU,IAAT,CAAcjB,MAAd;AACD;AACF,KATD;AAUA,WAAO,CAACO,QAAD,EAAWC,SAAX,CAAP;AACD,GAlByC,EAkBvC,CAACX,gBAAD,EAAmBD,UAAnB,CAlBuC,CAA1C;AAmBA,SAAO,CAACC,gBAAD,EAAmBO,cAAc,CAACc,MAAf,CAAsBC,OAAtB,CAAnB,EAAmDd,eAAe,CAACa,MAAhB,CAAuBC,OAAvB,CAAnD,CAAP;AACD,CA7BD;;AA8BA,eAAe1B,OAAf","sourcesContent":["import * as React from 'react';\nimport { groupKeysMap } from '../../_util/transKeys';\nconst useData = (dataSource, rowKey, targetKeys) => {\n  const mergedDataSource = React.useMemo(() => (dataSource || []).map(record => {\n    if (rowKey) {\n      return Object.assign(Object.assign({}, record), {\n        key: rowKey(record)\n      });\n    }\n    return record;\n  }), [dataSource, rowKey]);\n  const [leftDataSource, rightDataSource] = React.useMemo(() => {\n    var _a;\n    const leftData = [];\n    const rightData = Array.from({\n      length: (_a = targetKeys === null || targetKeys === void 0 ? void 0 : targetKeys.length) !== null && _a !== void 0 ? _a : 0\n    });\n    const targetKeysMap = groupKeysMap(targetKeys || []);\n    mergedDataSource.forEach(record => {\n      // rightData should be ordered by targetKeys\n      // leftData should be ordered by dataSource\n      if (targetKeysMap.has(record.key)) {\n        const idx = targetKeysMap.get(record.key);\n        rightData[idx] = record;\n      } else {\n        leftData.push(record);\n      }\n    });\n    return [leftData, rightData];\n  }, [mergedDataSource, targetKeys]);\n  return [mergedDataSource, leftDataSource.filter(Boolean), rightDataSource.filter(Boolean)];\n};\nexport default useData;"]},"metadata":{},"sourceType":"module"}