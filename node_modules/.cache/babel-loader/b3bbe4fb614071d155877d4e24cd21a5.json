{"ast":null,"code":"import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\n\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\n\n\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\n\nexport const matchScreen = (screens, screenSizes) => {\n  if (!screenSizes) {\n    return;\n  }\n\n  for (const breakpoint of responsiveArray) {\n    if (screens[breakpoint] && (screenSizes === null || screenSizes === void 0 ? void 0 : screenSizes[breakpoint]) !== undefined) {\n      return screenSizes[breakpoint];\n    }\n  }\n};\n\nconst useResponsiveObserver = () => {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token)); // To avoid repeat create instance, we add `useMemo` here.\n\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      responsiveMap,\n      matchHandlers: {},\n\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n\n      subscribe(func) {\n        if (!subscribers.size) {\n          this.register();\n        }\n\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n\n        if (!subscribers.size) {\n          this.unregister();\n        }\n      },\n\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      }\n\n    };\n  }, [token]);\n};\n\nexport default useResponsiveObserver;","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/_util/responsiveObserver.js"],"names":["React","useToken","responsiveArray","getResponsiveMap","token","xs","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","concat","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","matchScreen","screens","screenSizes","undefined","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","keys","matchMediaQuery","listener","_ref","matches","assign","mql","window","matchMedia","addListener","handler","removeListener","clear"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\nexport const matchScreen = (screens, screenSizes) => {\n  if (!screenSizes) {\n    return;\n  }\n  for (const breakpoint of responsiveArray) {\n    if (screens[breakpoint] && (screenSizes === null || screenSizes === void 0 ? void 0 : screenSizes[breakpoint]) !== undefined) {\n      return screenSizes[breakpoint];\n    }\n  }\n};\nconst useResponsiveObserver = () => {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      responsiveMap,\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) {\n          this.register();\n        }\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) {\n          this.unregister();\n        }\n      },\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      }\n    };\n  }, [token]);\n};\nexport default useResponsiveObserver;"]},"metadata":{},"sourceType":"module"}