{"ast":null,"code":"import _createForOfIteratorHelper from \"@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _class, _class2; // Copyright (c) Project Nayuki. (MIT License)\n// https://www.nayuki.io/page/qr-code-generator-library\n// Modification with code reorder and prettier\n// --------------------------------------------\n// Appends the given number of low-order bits of the given value\n// to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\n\n\nfunction appendBits(val, len, bb) {\n  if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError('Value out of range');\n\n  for (var i = len - 1; i >= 0; i-- // Append bit by bit\n  ) bb.push(val >>> i & 1);\n} // Returns true iff the i'th bit of x is set to 1.\n\n\nfunction getBit(x, i) {\n  return (x >>> i & 1) != 0;\n} // Throws an exception if the given condition is false.\n\n\nfunction assert(cond) {\n  if (!cond) throw new Error('Assertion error');\n}\n/*---- Public helper enumeration ----*/\n\n/*\n * Describes how a segment's data bits are numbererpreted. Immutable.\n */\n\n\nexport var Mode = /*#__PURE__*/function () {\n  function Mode(modeBits, numBitsCharCount) {\n    _classCallCheck(this, Mode);\n    /*-- Constructor and fields --*/\n    // The mode indicator bits, which is a unumber4 value (range 0 to 15).\n\n\n    _defineProperty(this, \"modeBits\", void 0); // Number of character count bits for three different version ranges.\n\n\n    _defineProperty(this, \"numBitsCharCount\", void 0);\n\n    this.modeBits = modeBits;\n    this.numBitsCharCount = numBitsCharCount;\n  }\n  /*-- Method --*/\n  // (Package-private) Returns the bit width of the character count field for a segment in\n  // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n\n\n  _createClass(Mode, [{\n    key: \"numCharCountBits\",\n    value: function numCharCountBits(ver) {\n      return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n    }\n  }]);\n\n  return Mode;\n}();\n/*---- Public helper enumeration ----*/\n\n/*\n * The error correction level in a QR Code symbol. Immutable.\n */\n\n_class = Mode;\n/*-- Constants --*/\n\n_defineProperty(Mode, \"NUMERIC\", new _class(0x1, [10, 12, 14]));\n\n_defineProperty(Mode, \"ALPHANUMERIC\", new _class(0x2, [9, 11, 13]));\n\n_defineProperty(Mode, \"BYTE\", new _class(0x4, [8, 16, 16]));\n\n_defineProperty(Mode, \"KANJI\", new _class(0x8, [8, 10, 12]));\n\n_defineProperty(Mode, \"ECI\", new _class(0x7, [0, 0, 0]));\n\nexport var Ecc = /*#__PURE__*/_createClass(function Ecc(ordinal, formatBits) {\n  _classCallCheck(this, Ecc); // The QR Code can tolerate about 30% erroneous codewords\n\n  /*-- Constructor and fields --*/\n  // In the range 0 to 3 (unsigned 2-bit numbereger).\n\n\n  _defineProperty(this, \"ordinal\", void 0); // (Package-private) In the range 0 to 3 (unsigned 2-bit numbereger).\n\n\n  _defineProperty(this, \"formatBits\", void 0);\n\n  this.ordinal = ordinal;\n  this.formatBits = formatBits;\n});\n/*\n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * The mid-level way to create a segment is to take the payload data\n * and call a static factory function such as QrSegment.makeNumeric().\n * The low-level way to create a segment is to custom-make the bit buffer\n * and call the QrSegment() constructor with appropriate values.\n * This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n */\n\n_class2 = Ecc;\n/*-- Constants --*/\n\n_defineProperty(Ecc, \"LOW\", new _class2(0, 1)); // The QR Code can tolerate about  7% erroneous codewords\n\n\n_defineProperty(Ecc, \"MEDIUM\", new _class2(1, 0)); // The QR Code can tolerate about 15% erroneous codewords\n\n\n_defineProperty(Ecc, \"QUARTILE\", new _class2(2, 3)); // The QR Code can tolerate about 25% erroneous codewords\n\n\n_defineProperty(Ecc, \"HIGH\", new _class2(3, 2));\n\nexport var QrSegment = /*#__PURE__*/function () {\n  // Creates a new QR Code segment with the given attributes and data.\n  // The character count (numChars) must agree with the mode and the bit buffer length,\n  // but the constranumber isn't checked. The given bit buffer is cloned and stored.\n  function QrSegment(mode, numChars, bitData) {\n    _classCallCheck(this, QrSegment);\n    /*-- Constructor (low level) and fields --*/\n    // The mode indicator of this segment.\n\n\n    _defineProperty(this, \"mode\", void 0); // The length of this segment's unencoded data. Measured in characters for\n    // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n    // Always zero or positive. Not the same as the data's bit length.\n\n\n    _defineProperty(this, \"numChars\", void 0); // The data bits of this segment. Accessed through getData().\n\n\n    _defineProperty(this, \"bitData\", void 0);\n\n    this.mode = mode;\n    this.numChars = numChars;\n    this.bitData = bitData;\n    if (numChars < 0) throw new RangeError('Invalid argument');\n    this.bitData = bitData.slice(); // Make defensive copy\n  }\n  /*-- Methods --*/\n  // Returns a new copy of the data bits of this segment.\n\n\n  _createClass(QrSegment, [{\n    key: \"getData\",\n    value: function getData() {\n      return this.bitData.slice(); // Make defensive copy\n    } // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n    // the given version. The result is infinity if a segment has too many characters to fit its length field.\n\n  }], [{\n    key: \"makeBytes\",\n    value:\n    /*-- Static factory functions (mid level) --*/\n    // Returns a segment representing the given binary data encoded in\n    // byte mode. All input byte arrays are acceptable. Any text string\n    // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n    function makeBytes(data) {\n      var bb = [];\n\n      var _iterator = _createForOfIteratorHelper(data),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var b = _step.value;\n          appendBits(b, 8, bb);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return new QrSegment(Mode.BYTE, data.length, bb);\n    } // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n\n  }, {\n    key: \"makeNumeric\",\n    value: function makeNumeric(digits) {\n      if (!QrSegment.isNumeric(digits)) throw new RangeError('String contains non-numeric characters');\n      var bb = [];\n\n      for (var i = 0; i < digits.length;) {\n        // Consume up to 3 digits per iteration\n        var n = Math.min(digits.length - i, 3);\n        appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n        i += n;\n      }\n\n      return new QrSegment(Mode.NUMERIC, digits.length, bb);\n    } // Returns a segment representing the given text string encoded in alphanumeric mode.\n    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\n  }, {\n    key: \"makeAlphanumeric\",\n    value: function makeAlphanumeric(text) {\n      if (!QrSegment.isAlphanumeric(text)) throw new RangeError('String contains unencodable characters in alphanumeric mode');\n      var bb = [];\n      var i;\n\n      for (i = 0; i + 2 <= text.length; i += 2) {\n        // Process groups of 2\n        var temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n        temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n        appendBits(temp, 11, bb);\n      }\n\n      if (i < text.length) // 1 character remaining\n        appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n      return new QrSegment(Mode.ALPHANUMERIC, text.length, bb);\n    } // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n    // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n\n  }, {\n    key: \"makeSegments\",\n    value: function makeSegments(text) {\n      // Select the most efficient segment encoding automatically\n      if (text == '') return [];else if (QrSegment.isNumeric(text)) return [QrSegment.makeNumeric(text)];else if (QrSegment.isAlphanumeric(text)) return [QrSegment.makeAlphanumeric(text)];else return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];\n    } // Returns a segment representing an Extended Channel Interpretation\n    // (ECI) designator with the given assignment value.\n\n  }, {\n    key: \"makeEci\",\n    value: function makeEci(assignVal) {\n      var bb = [];\n      if (assignVal < 0) throw new RangeError('ECI assignment value out of range');else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);else if (assignVal < 1 << 14) {\n        appendBits(2, 2, bb);\n        appendBits(assignVal, 14, bb);\n      } else if (assignVal < 1000000) {\n        appendBits(6, 3, bb);\n        appendBits(assignVal, 21, bb);\n      } else throw new RangeError('ECI assignment value out of range');\n      return new QrSegment(Mode.ECI, 0, bb);\n    } // Tests whether the given string can be encoded as a segment in numeric mode.\n    // A string is encodable iff each character is in the range 0 to 9.\n\n  }, {\n    key: \"isNumeric\",\n    value: function isNumeric(text) {\n      return QrSegment.NUMERIC_REGEX.test(text);\n    } // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n    // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n\n  }, {\n    key: \"isAlphanumeric\",\n    value: function isAlphanumeric(text) {\n      return QrSegment.ALPHANUMERIC_REGEX.test(text);\n    }\n  }, {\n    key: \"getTotalBits\",\n    value: function getTotalBits(segs, version) {\n      var result = 0;\n\n      var _iterator2 = _createForOfIteratorHelper(segs),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var seg = _step2.value;\n          var ccbits = seg.mode.numCharCountBits(version);\n          if (seg.numChars >= 1 << ccbits) return Infinity; // The segment's length doesn't fit the field's bit width\n\n          result += 4 + ccbits + seg.bitData.length;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return result;\n    } // Returns a new array of bytes representing the given string encoded in UTF-8.\n\n  }, {\n    key: \"toUtf8ByteArray\",\n    value: function toUtf8ByteArray(input) {\n      var str = encodeURI(input);\n      var result = [];\n\n      for (var i = 0; i < str.length; i++) {\n        if (str.charAt(i) != '%') result.push(str.charCodeAt(i));else {\n          result.push(parseInt(str.substring(i + 1, i + 3), 16));\n          i += 2;\n        }\n      }\n\n      return result;\n    }\n    /*-- Constants --*/\n    // Describes precisely all strings that are encodable in numeric mode.\n\n  }]);\n\n  return QrSegment;\n}();\n/*\n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n *\n * Ways to create a QR Code object:\n * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().\n * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().\n * - Low level: Custom-make the array of data codeword bytes (including\n *   segment headers and final padding, excluding error correction codewords),\n *   supply the appropriate version number, and call the QrCode() constructor.\n * (Note that all ways require supplying the desired error correction level.)\n */\n\n_defineProperty(QrSegment, \"NUMERIC_REGEX\", /^[0-9]*$/); // Describes precisely all strings that are encodable in alphanumeric mode.\n\n\n_defineProperty(QrSegment, \"ALPHANUMERIC_REGEX\", /^[A-Z0-9 $%*+.\\/:-]*$/); // The set of all legal characters in alphanumeric mode,\n// where each character value maps to the index in the string.\n\n\n_defineProperty(QrSegment, \"ALPHANUMERIC_CHARSET\", '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:');\n\nexport var QrCode = /*#__PURE__*/function () {\n  // Creates a new QR Code with the given version number,\n  // error correction level, data codeword bytes, and mask number.\n  // This is a low-level API that most users should not use directly.\n  // A mid-level API is the encodeSegments() function.\n  function QrCode( // The version number of this QR Code, which is between 1 and 40 (inclusive).\n  // This determines the size of this barcode.\n  version, // The error correction level used in this QR Code.\n  errorCorrectionLevel, dataCodewords, oriMsk) {\n    _classCallCheck(this, QrCode);\n    /*-- Fields --*/\n    // The width and height of this QR Code, measured in modules, between\n    // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n\n\n    _defineProperty(this, \"size\", void 0); // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n    // Even if a QR Code is created with automatic masking requested (mask = -1),\n    // the resulting object still has a mask value between 0 and 7.\n\n\n    _defineProperty(this, \"mask\", void 0); // The modules of this QR Code (false = light, true = dark).\n    // Immutable after constructor finishes. Accessed through getModule().\n\n\n    _defineProperty(this, \"modules\", []); // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n\n\n    _defineProperty(this, \"isFunction\", []);\n    /*-- Constructor (low level) and fields --*/\n    // The version number of this QR Code, which is between 1 and 40 (inclusive).\n    // This determines the size of this barcode.\n\n\n    _defineProperty(this, \"version\", void 0); // The error correction level used in this QR Code.\n\n\n    _defineProperty(this, \"errorCorrectionLevel\", void 0);\n\n    var msk = oriMsk;\n    this.version = version;\n    this.errorCorrectionLevel = errorCorrectionLevel; // Check scalar arguments\n\n    if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION) throw new RangeError('Version value out of range');\n    if (msk < -1 || msk > 7) throw new RangeError('Mask value out of range');\n    this.size = version * 4 + 17; // Initialize both grids to be size*size arrays of Boolean false\n\n    var row = [];\n\n    for (var i = 0; i < this.size; i++) row.push(false);\n\n    for (var _i = 0; _i < this.size; _i++) {\n      this.modules.push(row.slice()); // Initially all light\n\n      this.isFunction.push(row.slice());\n    } // Compute ECC, draw modules\n\n\n    this.drawFunctionPatterns();\n    var allCodewords = this.addEccAndInterleave(dataCodewords);\n    this.drawCodewords(allCodewords); // Do masking\n\n    if (msk == -1) {\n      // Automatically choose best mask\n      var minPenalty = 1000000000;\n\n      for (var _i2 = 0; _i2 < 8; _i2++) {\n        this.applyMask(_i2);\n        this.drawFormatBits(_i2);\n        var penalty = this.getPenaltyScore();\n\n        if (penalty < minPenalty) {\n          msk = _i2;\n          minPenalty = penalty;\n        }\n\n        this.applyMask(_i2); // Undoes the mask due to XOR\n      }\n    }\n\n    assert(0 <= msk && msk <= 7);\n    this.mask = msk;\n    this.applyMask(msk); // Apply the final choice of mask\n\n    this.drawFormatBits(msk); // Overwrite old format bits\n\n    this.isFunction = [];\n  }\n  /*-- Accessor methods --*/\n  // Returns the color of the module (pixel) at the given coordinates, which is false\n  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n  // If the given coordinates are out of bounds, then false (light) is returned.\n\n\n  _createClass(QrCode, [{\n    key: \"getModule\",\n    value: function getModule(x, y) {\n      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n    } // Modified to expose modules for easy access\n\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return this.modules;\n    }\n    /*-- Private helper methods for constructor: Drawing function modules --*/\n    // Reads this object's version field, and draws and marks all function modules.\n\n  }, {\n    key: \"drawFunctionPatterns\",\n    value: function drawFunctionPatterns() {\n      // Draw horizontal and vertical timing patterns\n      for (var i = 0; i < this.size; i++) {\n        this.setFunctionModule(6, i, i % 2 == 0);\n        this.setFunctionModule(i, 6, i % 2 == 0);\n      } // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n\n\n      this.drawFinderPattern(3, 3);\n      this.drawFinderPattern(this.size - 4, 3);\n      this.drawFinderPattern(3, this.size - 4); // Draw numerous alignment patterns\n\n      var alignPatPos = this.getAlignmentPatternPositions();\n      var numAlign = alignPatPos.length;\n\n      for (var _i3 = 0; _i3 < numAlign; _i3++) {\n        for (var j = 0; j < numAlign; j++) {\n          // Don't draw on the three finder corners\n          if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);\n        }\n      } // Draw configuration data\n\n\n      this.drawFormatBits(0); // Dummy mask value; overwritten later in the constructor\n\n      this.drawVersion();\n    } // Draws two copies of the format bits (with its own error correction code)\n    // based on the given mask and this object's error correction level field.\n\n  }, {\n    key: \"drawFormatBits\",\n    value: function drawFormatBits(mask) {\n      // Calculate error correction code and pack bits\n      var data = this.errorCorrectionLevel.formatBits << 3 | mask; // errCorrLvl is unumber2, mask is unumber3\n\n      var rem = data;\n\n      for (var i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 0x537;\n\n      var bits = (data << 10 | rem) ^ 0x5412; // unumber15\n\n      assert(bits >>> 15 == 0); // Draw first copy\n\n      for (var _i4 = 0; _i4 <= 5; _i4++) this.setFunctionModule(8, _i4, getBit(bits, _i4));\n\n      this.setFunctionModule(8, 7, getBit(bits, 6));\n      this.setFunctionModule(8, 8, getBit(bits, 7));\n      this.setFunctionModule(7, 8, getBit(bits, 8));\n\n      for (var _i5 = 9; _i5 < 15; _i5++) this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5)); // Draw second copy\n\n\n      for (var _i6 = 0; _i6 < 8; _i6++) this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));\n\n      for (var _i7 = 8; _i7 < 15; _i7++) this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));\n\n      this.setFunctionModule(8, this.size - 8, true); // Always dark\n    } // Draws two copies of the version bits (with its own error correction code),\n    // based on this object's version field, iff 7 <= version <= 40.\n\n  }, {\n    key: \"drawVersion\",\n    value: function drawVersion() {\n      if (this.version < 7) return; // Calculate error correction code and pack bits\n\n      var rem = this.version; // version is unumber6, in the range [7, 40]\n\n      for (var i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 0x1f25;\n\n      var bits = this.version << 12 | rem; // unumber18\n\n      assert(bits >>> 18 == 0); // Draw two copies\n\n      for (var _i8 = 0; _i8 < 18; _i8++) {\n        var color = getBit(bits, _i8);\n        var a = this.size - 11 + _i8 % 3;\n        var b = Math.floor(_i8 / 3);\n        this.setFunctionModule(a, b, color);\n        this.setFunctionModule(b, a, color);\n      }\n    } // Draws a 9*9 finder pattern including the border separator,\n    // with the center module at (x, y). Modules can be out of bounds.\n\n  }, {\n    key: \"drawFinderPattern\",\n    value: function drawFinderPattern(x, y) {\n      for (var dy = -4; dy <= 4; dy++) {\n        for (var dx = -4; dx <= 4; dx++) {\n          var dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm\n\n          var xx = x + dx;\n          var yy = y + dy;\n          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n        }\n      }\n    } // Draws a 5*5 alignment pattern, with the center module\n    // at (x, y). All modules must be in bounds.\n\n  }, {\n    key: \"drawAlignmentPattern\",\n    value: function drawAlignmentPattern(x, y) {\n      for (var dy = -2; dy <= 2; dy++) {\n        for (var dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n      }\n    } // Sets the color of a module and marks it as a function module.\n    // Only used by the constructor. Coordinates must be in bounds.\n\n  }, {\n    key: \"setFunctionModule\",\n    value: function setFunctionModule(x, y, isDark) {\n      this.modules[y][x] = isDark;\n      this.isFunction[y][x] = true;\n    }\n    /*-- Private helper methods for constructor: Codewords and masking --*/\n    // Returns a new byte string representing the given data with the appropriate error correction\n    // codewords appended to it, based on this object's version and error correction level.\n\n  }, {\n    key: \"addEccAndInterleave\",\n    value: function addEccAndInterleave(data) {\n      var ver = this.version;\n      var ecl = this.errorCorrectionLevel;\n      if (data.length != QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError('Invalid argument'); // Calculate parameter numbers\n\n      var numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n      var blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n      var rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);\n      var numShortBlocks = numBlocks - rawCodewords % numBlocks;\n      var shortBlockLen = Math.floor(rawCodewords / numBlocks); // Split data numbero blocks and append ECC to each block\n\n      var blocks = [];\n      var rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);\n\n      for (var i = 0, k = 0; i < numBlocks; i++) {\n        var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n        k += dat.length;\n        var ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n        if (i < numShortBlocks) dat.push(0);\n        blocks.push(dat.concat(ecc));\n      } // Interleave (not concatenate) the bytes from every block numbero a single sequence\n\n\n      var result = [];\n\n      var _loop = function _loop(_i9) {\n        blocks.forEach(function (block, j) {\n          // Skip the padding byte in short blocks\n          if (_i9 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9]);\n        });\n      };\n\n      for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {\n        _loop(_i9);\n      }\n\n      assert(result.length == rawCodewords);\n      return result;\n    } // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n    // data area of this QR Code. Function modules need to be marked off before this is called.\n\n  }, {\n    key: \"drawCodewords\",\n    value: function drawCodewords(data) {\n      if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError('Invalid argument');\n      var i = 0; // Bit index numbero the data\n      // Do the funny zigzag scan\n\n      for (var right = this.size - 1; right >= 1; right -= 2) {\n        // Index of right column in each column pair\n        if (right == 6) right = 5;\n\n        for (var vert = 0; vert < this.size; vert++) {\n          // Vertical counter\n          for (var j = 0; j < 2; j++) {\n            var x = right - j; // Actual x coordinate\n\n            var upward = (right + 1 & 2) == 0;\n            var y = upward ? this.size - 1 - vert : vert; // Actual y coordinate\n\n            if (!this.isFunction[y][x] && i < data.length * 8) {\n              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n              i++;\n            } // If this QR Code has any remainder bits (0 to 7), they were assigned as\n            // 0/false/light by the constructor and are left unchanged by this method\n\n          }\n        }\n      }\n\n      assert(i == data.length * 8);\n    } // XORs the codeword modules in this QR Code with the given mask pattern.\n    // The function modules must be marked and the codeword bits must be drawn\n    // before masking. Due to the arithmetic of XOR, calling applyMask() with\n    // the same mask value a second time will undo the mask. A final well-formed\n    // QR Code needs exactly one (not zero, two, etc.) mask applied.\n\n  }, {\n    key: \"applyMask\",\n    value: function applyMask(mask) {\n      if (mask < 0 || mask > 7) throw new RangeError('Mask value out of range');\n\n      for (var y = 0; y < this.size; y++) {\n        for (var x = 0; x < this.size; x++) {\n          var invert = void 0;\n\n          switch (mask) {\n            case 0:\n              invert = (x + y) % 2 == 0;\n              break;\n\n            case 1:\n              invert = y % 2 == 0;\n              break;\n\n            case 2:\n              invert = x % 3 == 0;\n              break;\n\n            case 3:\n              invert = (x + y) % 3 == 0;\n              break;\n\n            case 4:\n              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n              break;\n\n            case 5:\n              invert = x * y % 2 + x * y % 3 == 0;\n              break;\n\n            case 6:\n              invert = (x * y % 2 + x * y % 3) % 2 == 0;\n              break;\n\n            case 7:\n              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n              break;\n\n            default:\n              throw new Error('Unreachable');\n          }\n\n          if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n        }\n      }\n    } // Calculates and returns the penalty score based on state of this QR Code's current modules.\n    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n\n  }, {\n    key: \"getPenaltyScore\",\n    value: function getPenaltyScore() {\n      var result = 0; // Adjacent modules in row having same color, and finder-like patterns\n\n      for (var y = 0; y < this.size; y++) {\n        var runColor = false;\n        var runX = 0;\n        var runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n        for (var x = 0; x < this.size; x++) {\n          if (this.modules[y][x] == runColor) {\n            runX++;\n            if (runX == 5) result += QrCode.PENALTY_N1;else if (runX > 5) result++;\n          } else {\n            this.finderPenaltyAddHistory(runX, runHistory);\n            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n            runColor = this.modules[y][x];\n            runX = 1;\n          }\n        }\n\n        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;\n      } // Adjacent modules in column having same color, and finder-like patterns\n\n\n      for (var _x = 0; _x < this.size; _x++) {\n        var _runColor = false;\n        var runY = 0;\n        var _runHistory = [0, 0, 0, 0, 0, 0, 0];\n\n        for (var _y = 0; _y < this.size; _y++) {\n          if (this.modules[_y][_x] == _runColor) {\n            runY++;\n            if (runY == 5) result += QrCode.PENALTY_N1;else if (runY > 5) result++;\n          } else {\n            this.finderPenaltyAddHistory(runY, _runHistory);\n            if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * QrCode.PENALTY_N3;\n            _runColor = this.modules[_y][_x];\n            runY = 1;\n          }\n        }\n\n        result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode.PENALTY_N3;\n      } // 2*2 blocks of modules having same color\n\n\n      for (var _y2 = 0; _y2 < this.size - 1; _y2++) {\n        for (var _x2 = 0; _x2 < this.size - 1; _x2++) {\n          var color = this.modules[_y2][_x2];\n          if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += QrCode.PENALTY_N2;\n        }\n      } // Balance of dark and light modules\n\n\n      var dark = 0;\n\n      var _iterator3 = _createForOfIteratorHelper(this.modules),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var row = _step3.value;\n          dark = row.reduce(function (sum, color) {\n            return sum + (color ? 1 : 0);\n          }, dark);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var total = this.size * this.size; // Note that size is odd, so dark/total != 1/2\n      // Compute the smallest numbereger k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n\n      var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n      assert(0 <= k && k <= 9);\n      result += k * QrCode.PENALTY_N4;\n      assert(0 <= result && result <= 2568888); // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n\n      return result;\n    }\n    /*-- Private helper functions --*/\n    // Returns an ascending list of positions of alignment patterns for this version number.\n    // Each position is in the range [0,177), and are used on both the x and y axes.\n    // This could be implemented as lookup table of 40 variable-length lists of numberegers.\n\n  }, {\n    key: \"getAlignmentPatternPositions\",\n    value: function getAlignmentPatternPositions() {\n      if (this.version == 1) return [];else {\n        var numAlign = Math.floor(this.version / 7) + 2;\n        var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n        var result = [6];\n\n        for (var pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);\n\n        return result;\n      }\n    } // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n\n  }, {\n    key: \"finderPenaltyCountPatterns\",\n    value: // Can only be called immediately after a light run is added, and\n    // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n    function finderPenaltyCountPatterns(runHistory) {\n      var n = runHistory[1];\n      assert(n <= this.size * 3);\n      var core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n    } // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n\n  }, {\n    key: \"finderPenaltyTerminateAndCount\",\n    value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {\n      var currentRunLength = oriCurrentRunLength;\n\n      if (currentRunColor) {\n        // Terminate dark run\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        currentRunLength = 0;\n      }\n\n      currentRunLength += this.size; // Add light border to final run\n\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      return this.finderPenaltyCountPatterns(runHistory);\n    } // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n\n  }, {\n    key: \"finderPenaltyAddHistory\",\n    value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {\n      var currentRunLength = oriCurrentRunLength;\n      if (runHistory[0] == 0) currentRunLength += this.size; // Add light border to initial run\n\n      runHistory.pop();\n      runHistory.unshift(currentRunLength);\n    }\n    /*-- Constants and tables --*/\n    // The minimum version number supported in the QR Code Model 2 standard.\n\n  }], [{\n    key: \"encodeText\",\n    value:\n    /*-- Static factory functions (high level) --*/\n    // Returns a QR Code representing the given Unicode text string at the given error correction level.\n    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n    // Unicode code ponumbers (not UTF-16 code units) if the low error correction level is used. The smallest possible\n    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n    // ecl argument if it can be done without increasing the version.\n    function encodeText(text, ecl) {\n      var segs = QrSegment.makeSegments(text);\n      return QrCode.encodeSegments(segs, ecl);\n    } // Returns a QR Code representing the given binary data at the given error correction level.\n    // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n\n  }, {\n    key: \"encodeBinary\",\n    value: function encodeBinary(data, ecl) {\n      var seg = QrSegment.makeBytes(data);\n      return QrCode.encodeSegments([seg], ecl);\n    }\n    /*-- Static factory functions (mid level) --*/\n    // Returns a QR Code representing the given segments with the given encoding parameters.\n    // The smallest possible QR Code version within the given range is automatically\n    // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n    // may be higher than the ecl argument if it can be done without increasing the\n    // version. The mask number is either between 0 to 7 (inclusive) to force that\n    // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n    // This function allows the user to create a custom sequence of segments that switches\n    // between modes (such as alphanumeric and byte) to encode text in less space.\n    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n\n  }, {\n    key: \"encodeSegments\",\n    value: function encodeSegments(segs, oriEcl) {\n      var minVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var maxVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n      var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n      var boostEcl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError('Invalid value'); // Find the minimal version number to use\n\n      var version;\n      var dataUsedBits;\n\n      for (version = minVersion;; version++) {\n        var _dataCapacityBits = QrCode.getNumDataCodewords(version, oriEcl) * 8; // Number of data bits available\n\n\n        var usedBits = QrSegment.getTotalBits(segs, version);\n\n        if (usedBits <= _dataCapacityBits) {\n          dataUsedBits = usedBits;\n          break; // This version number is found to be suitable\n        }\n\n        if (version >= maxVersion) // All versions in the range could not fit the given data\n          throw new RangeError('Data too long');\n      }\n\n      var ecl = oriEcl; // Increase the error correction level while the data still fits in the current version number\n\n      for (var _i10 = 0, _arr = [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]; _i10 < _arr.length; _i10++) {\n        var newEcl = _arr[_i10]; // From low to high\n\n        if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n      } // Concatenate all segments to create the data bit string\n\n\n      var bb = [];\n\n      var _iterator4 = _createForOfIteratorHelper(segs),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var seg = _step4.value;\n          appendBits(seg.mode.modeBits, 4, bb);\n          appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n\n          var _iterator5 = _createForOfIteratorHelper(seg.getData()),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var b = _step5.value;\n              bb.push(b);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      assert(bb.length == dataUsedBits); // Add terminator and pad up to a byte if applicable\n\n      var dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;\n      assert(bb.length <= dataCapacityBits);\n      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n      appendBits(0, (8 - bb.length % 8) % 8, bb);\n      assert(bb.length % 8 == 0); // Pad with alternating bytes until data capacity is reached\n\n      for (var padByte = 0xec; bb.length < dataCapacityBits; padByte ^= 0xec ^ 0x11) appendBits(padByte, 8, bb); // Pack bits numbero bytes in big endian\n\n\n      var dataCodewords = [];\n\n      while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);\n\n      bb.forEach(function (b, i) {\n        return dataCodewords[i >>> 3] |= b << 7 - (i & 7);\n      }); // Create the QR Code object\n\n      return new QrCode(version, ecl, dataCodewords, mask);\n    }\n  }, {\n    key: \"getNumRawDataModules\",\n    value: function getNumRawDataModules(ver) {\n      if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION) throw new RangeError('Version number out of range');\n      var result = (16 * ver + 128) * ver + 64;\n\n      if (ver >= 2) {\n        var numAlign = Math.floor(ver / 7) + 2;\n        result -= (25 * numAlign - 10) * numAlign - 55;\n        if (ver >= 7) result -= 36;\n      }\n\n      assert(208 <= result && result <= 29648);\n      return result;\n    } // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n    // QR Code of the given version number and error correction level, with remainder bits discarded.\n    // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n\n  }, {\n    key: \"getNumDataCodewords\",\n    value: function getNumDataCodewords(ver, ecl) {\n      return Math.floor(QrCode.getNumRawDataModules(ver) / 8) - QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n    } // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n\n  }, {\n    key: \"reedSolomonComputeDivisor\",\n    value: function reedSolomonComputeDivisor(degree) {\n      if (degree < 1 || degree > 255) throw new RangeError('Degree out of range'); // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n      // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the unumber8 array [255, 8, 93].\n\n      var result = [];\n\n      for (var i = 0; i < degree - 1; i++) result.push(0);\n\n      result.push(1); // Start off with the monomial x^0\n      // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n      // and drop the highest monomial term which is always 1x^degree.\n      // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n\n      var root = 1;\n\n      for (var _i11 = 0; _i11 < degree; _i11++) {\n        // Multiply the current product by (x - r^i)\n        for (var j = 0; j < result.length; j++) {\n          result[j] = QrCode.reedSolomonMultiply(result[j], root);\n          if (j + 1 < result.length) result[j] ^= result[j + 1];\n        }\n\n        root = QrCode.reedSolomonMultiply(root, 0x02);\n      }\n\n      return result;\n    } // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n\n  }, {\n    key: \"reedSolomonComputeRemainder\",\n    value: function reedSolomonComputeRemainder(data, divisor) {\n      var result = divisor.map(function () {\n        return 0;\n      });\n\n      var _iterator6 = _createForOfIteratorHelper(data),\n          _step6;\n\n      try {\n        var _loop2 = function _loop2() {\n          var b = _step6.value; // Polynomial division\n\n          var factor = b ^ result.shift();\n          result.push(0);\n          divisor.forEach(function (coef, i) {\n            return result[i] ^= QrCode.reedSolomonMultiply(coef, factor);\n          });\n        };\n\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      return result;\n    } // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n    // are unsigned 8-bit numberegers. This could be implemented as a lookup table of 256*256 entries of unumber8.\n\n  }, {\n    key: \"reedSolomonMultiply\",\n    value: function reedSolomonMultiply(x, y) {\n      if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError('Byte out of range'); // Russian peasant multiplication\n\n      var z = 0;\n\n      for (var i = 7; i >= 0; i--) {\n        z = z << 1 ^ (z >>> 7) * 0x11d;\n        z ^= (y >>> i & 1) * x;\n      }\n\n      assert(z >>> 8 == 0);\n      return z;\n    }\n  }]);\n\n  return QrCode;\n}();\n\n_defineProperty(QrCode, \"MIN_VERSION\", 1); // The maximum version number supported in the QR Code Model 2 standard.\n\n\n_defineProperty(QrCode, \"MAX_VERSION\", 40); // For use in getPenaltyScore(), when evaluating which mask is best.\n\n\n_defineProperty(QrCode, \"PENALTY_N1\", 3);\n\n_defineProperty(QrCode, \"PENALTY_N2\", 3);\n\n_defineProperty(QrCode, \"PENALTY_N3\", 40);\n\n_defineProperty(QrCode, \"PENALTY_N4\", 10);\n\n_defineProperty(QrCode, \"ECC_CODEWORDS_PER_BLOCK\", [// Version: (note that index 0 is for padding, and is set to an illegal value)\n//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // Low\n[-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28], // Medium\n[-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30], // Quartile\n[-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] // High\n]);\n\n_defineProperty(QrCode, \"NUM_ERROR_CORRECTION_BLOCKS\", [// Version: (note that index 0 is for padding, and is set to an illegal value)\n//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25], // Low\n[-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49], // Medium\n[-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68], // Quartile\n[-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] // High\n]);","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/@rc-component/qrcode/es/libs/qrcodegen.js"],"names":["_createForOfIteratorHelper","_classCallCheck","_createClass","_defineProperty","_class","_class2","appendBits","val","len","bb","RangeError","i","push","getBit","x","assert","cond","Error","Mode","modeBits","numBitsCharCount","key","value","numCharCountBits","ver","Math","floor","Ecc","ordinal","formatBits","QrSegment","mode","numChars","bitData","slice","getData","makeBytes","data","_iterator","_step","s","n","done","b","err","e","f","BYTE","length","makeNumeric","digits","isNumeric","min","parseInt","substring","NUMERIC","makeAlphanumeric","text","isAlphanumeric","temp","ALPHANUMERIC_CHARSET","indexOf","charAt","ALPHANUMERIC","makeSegments","toUtf8ByteArray","makeEci","assignVal","ECI","NUMERIC_REGEX","test","ALPHANUMERIC_REGEX","getTotalBits","segs","version","result","_iterator2","_step2","seg","ccbits","Infinity","input","str","encodeURI","charCodeAt","QrCode","errorCorrectionLevel","dataCodewords","oriMsk","msk","MIN_VERSION","MAX_VERSION","size","row","_i","modules","isFunction","drawFunctionPatterns","allCodewords","addEccAndInterleave","drawCodewords","minPenalty","_i2","applyMask","drawFormatBits","penalty","getPenaltyScore","mask","getModule","y","getModules","setFunctionModule","drawFinderPattern","alignPatPos","getAlignmentPatternPositions","numAlign","_i3","j","drawAlignmentPattern","drawVersion","rem","bits","_i4","_i5","_i6","_i7","_i8","color","a","dy","dx","dist","max","abs","xx","yy","isDark","ecl","getNumDataCodewords","numBlocks","NUM_ERROR_CORRECTION_BLOCKS","blockEccLen","ECC_CODEWORDS_PER_BLOCK","rawCodewords","getNumRawDataModules","numShortBlocks","shortBlockLen","blocks","rsDiv","reedSolomonComputeDivisor","k","dat","ecc","reedSolomonComputeRemainder","concat","_loop","_i9","forEach","block","right","vert","upward","invert","runColor","runX","runHistory","PENALTY_N1","finderPenaltyAddHistory","finderPenaltyCountPatterns","PENALTY_N3","finderPenaltyTerminateAndCount","_x","_runColor","runY","_runHistory","_y","_y2","_x2","PENALTY_N2","dark","_iterator3","_step3","reduce","sum","total","ceil","PENALTY_N4","step","pos","splice","core","currentRunColor","oriCurrentRunLength","currentRunLength","pop","unshift","encodeText","encodeSegments","encodeBinary","oriEcl","minVersion","arguments","undefined","maxVersion","boostEcl","dataUsedBits","_dataCapacityBits","usedBits","_i10","_arr","MEDIUM","QUARTILE","HIGH","newEcl","_iterator4","_step4","_iterator5","_step5","dataCapacityBits","padByte","degree","root","_i11","reedSolomonMultiply","divisor","map","_iterator6","_step6","_loop2","factor","shift","coef","z"],"mappings":"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","sourcesContent":["import _createForOfIteratorHelper from \"@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _class, _class2;\n// Copyright (c) Project Nayuki. (MIT License)\n// https://www.nayuki.io/page/qr-code-generator-library\n\n// Modification with code reorder and prettier\n\n// --------------------------------------------\n\n// Appends the given number of low-order bits of the given value\n// to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.\nfunction appendBits(val, len, bb) {\n  if (len < 0 || len > 31 || val >>> len != 0) throw new RangeError('Value out of range');\n  for (var i = len - 1; i >= 0; i-- // Append bit by bit\n  ) bb.push(val >>> i & 1);\n}\n\n// Returns true iff the i'th bit of x is set to 1.\nfunction getBit(x, i) {\n  return (x >>> i & 1) != 0;\n}\n\n// Throws an exception if the given condition is false.\nfunction assert(cond) {\n  if (!cond) throw new Error('Assertion error');\n}\n\n/*---- Public helper enumeration ----*/\n/*\n * Describes how a segment's data bits are numbererpreted. Immutable.\n */\nexport var Mode = /*#__PURE__*/function () {\n  function Mode(modeBits, numBitsCharCount) {\n    _classCallCheck(this, Mode);\n    /*-- Constructor and fields --*/\n    // The mode indicator bits, which is a unumber4 value (range 0 to 15).\n    _defineProperty(this, \"modeBits\", void 0);\n    // Number of character count bits for three different version ranges.\n    _defineProperty(this, \"numBitsCharCount\", void 0);\n    this.modeBits = modeBits;\n    this.numBitsCharCount = numBitsCharCount;\n  }\n\n  /*-- Method --*/\n\n  // (Package-private) Returns the bit width of the character count field for a segment in\n  // this mode in a QR Code at the given version number. The result is in the range [0, 16].\n  _createClass(Mode, [{\n    key: \"numCharCountBits\",\n    value: function numCharCountBits(ver) {\n      return this.numBitsCharCount[Math.floor((ver + 7) / 17)];\n    }\n  }]);\n  return Mode;\n}();\n\n/*---- Public helper enumeration ----*/\n\n/*\n * The error correction level in a QR Code symbol. Immutable.\n */\n_class = Mode;\n/*-- Constants --*/\n_defineProperty(Mode, \"NUMERIC\", new _class(0x1, [10, 12, 14]));\n_defineProperty(Mode, \"ALPHANUMERIC\", new _class(0x2, [9, 11, 13]));\n_defineProperty(Mode, \"BYTE\", new _class(0x4, [8, 16, 16]));\n_defineProperty(Mode, \"KANJI\", new _class(0x8, [8, 10, 12]));\n_defineProperty(Mode, \"ECI\", new _class(0x7, [0, 0, 0]));\nexport var Ecc = /*#__PURE__*/_createClass(function Ecc(ordinal, formatBits) {\n  _classCallCheck(this, Ecc);\n  // The QR Code can tolerate about 30% erroneous codewords\n  /*-- Constructor and fields --*/\n  // In the range 0 to 3 (unsigned 2-bit numbereger).\n  _defineProperty(this, \"ordinal\", void 0);\n  // (Package-private) In the range 0 to 3 (unsigned 2-bit numbereger).\n  _defineProperty(this, \"formatBits\", void 0);\n  this.ordinal = ordinal;\n  this.formatBits = formatBits;\n});\n\n/*\n * A segment of character/binary/control data in a QR Code symbol.\n * Instances of this class are immutable.\n * The mid-level way to create a segment is to take the payload data\n * and call a static factory function such as QrSegment.makeNumeric().\n * The low-level way to create a segment is to custom-make the bit buffer\n * and call the QrSegment() constructor with appropriate values.\n * This segment class imposes no length restrictions, but QR Codes have restrictions.\n * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.\n * Any segment longer than this is meaningless for the purpose of generating QR Codes.\n */\n_class2 = Ecc;\n/*-- Constants --*/\n_defineProperty(Ecc, \"LOW\", new _class2(0, 1));\n// The QR Code can tolerate about  7% erroneous codewords\n_defineProperty(Ecc, \"MEDIUM\", new _class2(1, 0));\n// The QR Code can tolerate about 15% erroneous codewords\n_defineProperty(Ecc, \"QUARTILE\", new _class2(2, 3));\n// The QR Code can tolerate about 25% erroneous codewords\n_defineProperty(Ecc, \"HIGH\", new _class2(3, 2));\nexport var QrSegment = /*#__PURE__*/function () {\n  // Creates a new QR Code segment with the given attributes and data.\n  // The character count (numChars) must agree with the mode and the bit buffer length,\n  // but the constranumber isn't checked. The given bit buffer is cloned and stored.\n  function QrSegment(mode, numChars, bitData) {\n    _classCallCheck(this, QrSegment);\n    /*-- Constructor (low level) and fields --*/\n    // The mode indicator of this segment.\n    _defineProperty(this, \"mode\", void 0);\n    // The length of this segment's unencoded data. Measured in characters for\n    // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.\n    // Always zero or positive. Not the same as the data's bit length.\n    _defineProperty(this, \"numChars\", void 0);\n    // The data bits of this segment. Accessed through getData().\n    _defineProperty(this, \"bitData\", void 0);\n    this.mode = mode;\n    this.numChars = numChars;\n    this.bitData = bitData;\n    if (numChars < 0) throw new RangeError('Invalid argument');\n    this.bitData = bitData.slice(); // Make defensive copy\n  }\n\n  /*-- Methods --*/\n\n  // Returns a new copy of the data bits of this segment.\n  _createClass(QrSegment, [{\n    key: \"getData\",\n    value: function getData() {\n      return this.bitData.slice(); // Make defensive copy\n    }\n\n    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at\n    // the given version. The result is infinity if a segment has too many characters to fit its length field.\n  }], [{\n    key: \"makeBytes\",\n    value: /*-- Static factory functions (mid level) --*/\n\n    // Returns a segment representing the given binary data encoded in\n    // byte mode. All input byte arrays are acceptable. Any text string\n    // can be converted to UTF-8 bytes and encoded as a byte mode segment.\n    function makeBytes(data) {\n      var bb = [];\n      var _iterator = _createForOfIteratorHelper(data),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var b = _step.value;\n          appendBits(b, 8, bb);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return new QrSegment(Mode.BYTE, data.length, bb);\n    }\n\n    // Returns a segment representing the given string of decimal digits encoded in numeric mode.\n  }, {\n    key: \"makeNumeric\",\n    value: function makeNumeric(digits) {\n      if (!QrSegment.isNumeric(digits)) throw new RangeError('String contains non-numeric characters');\n      var bb = [];\n      for (var i = 0; i < digits.length;) {\n        // Consume up to 3 digits per iteration\n        var n = Math.min(digits.length - i, 3);\n        appendBits(parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);\n        i += n;\n      }\n      return new QrSegment(Mode.NUMERIC, digits.length, bb);\n    }\n\n    // Returns a segment representing the given text string encoded in alphanumeric mode.\n    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,\n    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n  }, {\n    key: \"makeAlphanumeric\",\n    value: function makeAlphanumeric(text) {\n      if (!QrSegment.isAlphanumeric(text)) throw new RangeError('String contains unencodable characters in alphanumeric mode');\n      var bb = [];\n      var i;\n      for (i = 0; i + 2 <= text.length; i += 2) {\n        // Process groups of 2\n        var temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;\n        temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));\n        appendBits(temp, 11, bb);\n      }\n      if (i < text.length)\n        // 1 character remaining\n        appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);\n      return new QrSegment(Mode.ALPHANUMERIC, text.length, bb);\n    }\n\n    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.\n    // The result may use various segment modes and switch modes to optimize the length of the bit stream.\n  }, {\n    key: \"makeSegments\",\n    value: function makeSegments(text) {\n      // Select the most efficient segment encoding automatically\n      if (text == '') return [];else if (QrSegment.isNumeric(text)) return [QrSegment.makeNumeric(text)];else if (QrSegment.isAlphanumeric(text)) return [QrSegment.makeAlphanumeric(text)];else return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];\n    }\n\n    // Returns a segment representing an Extended Channel Interpretation\n    // (ECI) designator with the given assignment value.\n  }, {\n    key: \"makeEci\",\n    value: function makeEci(assignVal) {\n      var bb = [];\n      if (assignVal < 0) throw new RangeError('ECI assignment value out of range');else if (assignVal < 1 << 7) appendBits(assignVal, 8, bb);else if (assignVal < 1 << 14) {\n        appendBits(2, 2, bb);\n        appendBits(assignVal, 14, bb);\n      } else if (assignVal < 1000000) {\n        appendBits(6, 3, bb);\n        appendBits(assignVal, 21, bb);\n      } else throw new RangeError('ECI assignment value out of range');\n      return new QrSegment(Mode.ECI, 0, bb);\n    }\n\n    // Tests whether the given string can be encoded as a segment in numeric mode.\n    // A string is encodable iff each character is in the range 0 to 9.\n  }, {\n    key: \"isNumeric\",\n    value: function isNumeric(text) {\n      return QrSegment.NUMERIC_REGEX.test(text);\n    }\n\n    // Tests whether the given string can be encoded as a segment in alphanumeric mode.\n    // A string is encodable iff each character is in the following set: 0 to 9, A to Z\n    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.\n  }, {\n    key: \"isAlphanumeric\",\n    value: function isAlphanumeric(text) {\n      return QrSegment.ALPHANUMERIC_REGEX.test(text);\n    }\n  }, {\n    key: \"getTotalBits\",\n    value: function getTotalBits(segs, version) {\n      var result = 0;\n      var _iterator2 = _createForOfIteratorHelper(segs),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var seg = _step2.value;\n          var ccbits = seg.mode.numCharCountBits(version);\n          if (seg.numChars >= 1 << ccbits) return Infinity; // The segment's length doesn't fit the field's bit width\n          result += 4 + ccbits + seg.bitData.length;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return result;\n    }\n\n    // Returns a new array of bytes representing the given string encoded in UTF-8.\n  }, {\n    key: \"toUtf8ByteArray\",\n    value: function toUtf8ByteArray(input) {\n      var str = encodeURI(input);\n      var result = [];\n      for (var i = 0; i < str.length; i++) {\n        if (str.charAt(i) != '%') result.push(str.charCodeAt(i));else {\n          result.push(parseInt(str.substring(i + 1, i + 3), 16));\n          i += 2;\n        }\n      }\n      return result;\n    }\n\n    /*-- Constants --*/\n\n    // Describes precisely all strings that are encodable in numeric mode.\n  }]);\n  return QrSegment;\n}();\n\n/*\n * A QR Code symbol, which is a type of two-dimension barcode.\n * Invented by Denso Wave and described in the ISO/IEC 18004 standard.\n * Instances of this class represent an immutable square grid of dark and light cells.\n * The class provides static factory functions to create a QR Code from text or binary data.\n * The class covers the QR Code Model 2 specification, supporting all versions (sizes)\n * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.\n *\n * Ways to create a QR Code object:\n * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().\n * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().\n * - Low level: Custom-make the array of data codeword bytes (including\n *   segment headers and final padding, excluding error correction codewords),\n *   supply the appropriate version number, and call the QrCode() constructor.\n * (Note that all ways require supplying the desired error correction level.)\n */\n_defineProperty(QrSegment, \"NUMERIC_REGEX\", /^[0-9]*$/);\n// Describes precisely all strings that are encodable in alphanumeric mode.\n_defineProperty(QrSegment, \"ALPHANUMERIC_REGEX\", /^[A-Z0-9 $%*+.\\/:-]*$/);\n// The set of all legal characters in alphanumeric mode,\n// where each character value maps to the index in the string.\n_defineProperty(QrSegment, \"ALPHANUMERIC_CHARSET\", '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:');\nexport var QrCode = /*#__PURE__*/function () {\n  // Creates a new QR Code with the given version number,\n  // error correction level, data codeword bytes, and mask number.\n  // This is a low-level API that most users should not use directly.\n  // A mid-level API is the encodeSegments() function.\n  function QrCode(\n  // The version number of this QR Code, which is between 1 and 40 (inclusive).\n  // This determines the size of this barcode.\n  version,\n  // The error correction level used in this QR Code.\n  errorCorrectionLevel, dataCodewords, oriMsk) {\n    _classCallCheck(this, QrCode);\n    /*-- Fields --*/\n    // The width and height of this QR Code, measured in modules, between\n    // 21 and 177 (inclusive). This is equal to version * 4 + 17.\n    _defineProperty(this, \"size\", void 0);\n    // The index of the mask pattern used in this QR Code, which is between 0 and 7 (inclusive).\n    // Even if a QR Code is created with automatic masking requested (mask = -1),\n    // the resulting object still has a mask value between 0 and 7.\n    _defineProperty(this, \"mask\", void 0);\n    // The modules of this QR Code (false = light, true = dark).\n    // Immutable after constructor finishes. Accessed through getModule().\n    _defineProperty(this, \"modules\", []);\n    // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.\n    _defineProperty(this, \"isFunction\", []);\n    /*-- Constructor (low level) and fields --*/\n    // The version number of this QR Code, which is between 1 and 40 (inclusive).\n    // This determines the size of this barcode.\n    _defineProperty(this, \"version\", void 0);\n    // The error correction level used in this QR Code.\n    _defineProperty(this, \"errorCorrectionLevel\", void 0);\n    var msk = oriMsk;\n    this.version = version;\n    this.errorCorrectionLevel = errorCorrectionLevel;\n    // Check scalar arguments\n    if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION) throw new RangeError('Version value out of range');\n    if (msk < -1 || msk > 7) throw new RangeError('Mask value out of range');\n    this.size = version * 4 + 17;\n\n    // Initialize both grids to be size*size arrays of Boolean false\n    var row = [];\n    for (var i = 0; i < this.size; i++) row.push(false);\n    for (var _i = 0; _i < this.size; _i++) {\n      this.modules.push(row.slice()); // Initially all light\n      this.isFunction.push(row.slice());\n    }\n\n    // Compute ECC, draw modules\n    this.drawFunctionPatterns();\n    var allCodewords = this.addEccAndInterleave(dataCodewords);\n    this.drawCodewords(allCodewords);\n\n    // Do masking\n    if (msk == -1) {\n      // Automatically choose best mask\n      var minPenalty = 1000000000;\n      for (var _i2 = 0; _i2 < 8; _i2++) {\n        this.applyMask(_i2);\n        this.drawFormatBits(_i2);\n        var penalty = this.getPenaltyScore();\n        if (penalty < minPenalty) {\n          msk = _i2;\n          minPenalty = penalty;\n        }\n        this.applyMask(_i2); // Undoes the mask due to XOR\n      }\n    }\n    assert(0 <= msk && msk <= 7);\n    this.mask = msk;\n    this.applyMask(msk); // Apply the final choice of mask\n    this.drawFormatBits(msk); // Overwrite old format bits\n\n    this.isFunction = [];\n  }\n\n  /*-- Accessor methods --*/\n\n  // Returns the color of the module (pixel) at the given coordinates, which is false\n  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).\n  // If the given coordinates are out of bounds, then false (light) is returned.\n  _createClass(QrCode, [{\n    key: \"getModule\",\n    value: function getModule(x, y) {\n      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];\n    }\n\n    // Modified to expose modules for easy access\n  }, {\n    key: \"getModules\",\n    value: function getModules() {\n      return this.modules;\n    }\n\n    /*-- Private helper methods for constructor: Drawing function modules --*/\n\n    // Reads this object's version field, and draws and marks all function modules.\n  }, {\n    key: \"drawFunctionPatterns\",\n    value: function drawFunctionPatterns() {\n      // Draw horizontal and vertical timing patterns\n      for (var i = 0; i < this.size; i++) {\n        this.setFunctionModule(6, i, i % 2 == 0);\n        this.setFunctionModule(i, 6, i % 2 == 0);\n      }\n\n      // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)\n      this.drawFinderPattern(3, 3);\n      this.drawFinderPattern(this.size - 4, 3);\n      this.drawFinderPattern(3, this.size - 4);\n\n      // Draw numerous alignment patterns\n      var alignPatPos = this.getAlignmentPatternPositions();\n      var numAlign = alignPatPos.length;\n      for (var _i3 = 0; _i3 < numAlign; _i3++) {\n        for (var j = 0; j < numAlign; j++) {\n          // Don't draw on the three finder corners\n          if (!(_i3 == 0 && j == 0 || _i3 == 0 && j == numAlign - 1 || _i3 == numAlign - 1 && j == 0)) this.drawAlignmentPattern(alignPatPos[_i3], alignPatPos[j]);\n        }\n      }\n\n      // Draw configuration data\n      this.drawFormatBits(0); // Dummy mask value; overwritten later in the constructor\n      this.drawVersion();\n    }\n\n    // Draws two copies of the format bits (with its own error correction code)\n    // based on the given mask and this object's error correction level field.\n  }, {\n    key: \"drawFormatBits\",\n    value: function drawFormatBits(mask) {\n      // Calculate error correction code and pack bits\n      var data = this.errorCorrectionLevel.formatBits << 3 | mask; // errCorrLvl is unumber2, mask is unumber3\n      var rem = data;\n      for (var i = 0; i < 10; i++) rem = rem << 1 ^ (rem >>> 9) * 0x537;\n      var bits = (data << 10 | rem) ^ 0x5412; // unumber15\n      assert(bits >>> 15 == 0);\n\n      // Draw first copy\n      for (var _i4 = 0; _i4 <= 5; _i4++) this.setFunctionModule(8, _i4, getBit(bits, _i4));\n      this.setFunctionModule(8, 7, getBit(bits, 6));\n      this.setFunctionModule(8, 8, getBit(bits, 7));\n      this.setFunctionModule(7, 8, getBit(bits, 8));\n      for (var _i5 = 9; _i5 < 15; _i5++) this.setFunctionModule(14 - _i5, 8, getBit(bits, _i5));\n\n      // Draw second copy\n      for (var _i6 = 0; _i6 < 8; _i6++) this.setFunctionModule(this.size - 1 - _i6, 8, getBit(bits, _i6));\n      for (var _i7 = 8; _i7 < 15; _i7++) this.setFunctionModule(8, this.size - 15 + _i7, getBit(bits, _i7));\n      this.setFunctionModule(8, this.size - 8, true); // Always dark\n    }\n\n    // Draws two copies of the version bits (with its own error correction code),\n    // based on this object's version field, iff 7 <= version <= 40.\n  }, {\n    key: \"drawVersion\",\n    value: function drawVersion() {\n      if (this.version < 7) return;\n\n      // Calculate error correction code and pack bits\n      var rem = this.version; // version is unumber6, in the range [7, 40]\n      for (var i = 0; i < 12; i++) rem = rem << 1 ^ (rem >>> 11) * 0x1f25;\n      var bits = this.version << 12 | rem; // unumber18\n      assert(bits >>> 18 == 0);\n\n      // Draw two copies\n      for (var _i8 = 0; _i8 < 18; _i8++) {\n        var color = getBit(bits, _i8);\n        var a = this.size - 11 + _i8 % 3;\n        var b = Math.floor(_i8 / 3);\n        this.setFunctionModule(a, b, color);\n        this.setFunctionModule(b, a, color);\n      }\n    }\n\n    // Draws a 9*9 finder pattern including the border separator,\n    // with the center module at (x, y). Modules can be out of bounds.\n  }, {\n    key: \"drawFinderPattern\",\n    value: function drawFinderPattern(x, y) {\n      for (var dy = -4; dy <= 4; dy++) {\n        for (var dx = -4; dx <= 4; dx++) {\n          var dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm\n          var xx = x + dx;\n          var yy = y + dy;\n          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size) this.setFunctionModule(xx, yy, dist != 2 && dist != 4);\n        }\n      }\n    }\n\n    // Draws a 5*5 alignment pattern, with the center module\n    // at (x, y). All modules must be in bounds.\n  }, {\n    key: \"drawAlignmentPattern\",\n    value: function drawAlignmentPattern(x, y) {\n      for (var dy = -2; dy <= 2; dy++) {\n        for (var dx = -2; dx <= 2; dx++) this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);\n      }\n    }\n\n    // Sets the color of a module and marks it as a function module.\n    // Only used by the constructor. Coordinates must be in bounds.\n  }, {\n    key: \"setFunctionModule\",\n    value: function setFunctionModule(x, y, isDark) {\n      this.modules[y][x] = isDark;\n      this.isFunction[y][x] = true;\n    }\n\n    /*-- Private helper methods for constructor: Codewords and masking --*/\n\n    // Returns a new byte string representing the given data with the appropriate error correction\n    // codewords appended to it, based on this object's version and error correction level.\n  }, {\n    key: \"addEccAndInterleave\",\n    value: function addEccAndInterleave(data) {\n      var ver = this.version;\n      var ecl = this.errorCorrectionLevel;\n      if (data.length != QrCode.getNumDataCodewords(ver, ecl)) throw new RangeError('Invalid argument');\n\n      // Calculate parameter numbers\n      var numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n      var blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];\n      var rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);\n      var numShortBlocks = numBlocks - rawCodewords % numBlocks;\n      var shortBlockLen = Math.floor(rawCodewords / numBlocks);\n\n      // Split data numbero blocks and append ECC to each block\n      var blocks = [];\n      var rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);\n      for (var i = 0, k = 0; i < numBlocks; i++) {\n        var dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));\n        k += dat.length;\n        var ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);\n        if (i < numShortBlocks) dat.push(0);\n        blocks.push(dat.concat(ecc));\n      }\n\n      // Interleave (not concatenate) the bytes from every block numbero a single sequence\n      var result = [];\n      var _loop = function _loop(_i9) {\n        blocks.forEach(function (block, j) {\n          // Skip the padding byte in short blocks\n          if (_i9 != shortBlockLen - blockEccLen || j >= numShortBlocks) result.push(block[_i9]);\n        });\n      };\n      for (var _i9 = 0; _i9 < blocks[0].length; _i9++) {\n        _loop(_i9);\n      }\n      assert(result.length == rawCodewords);\n      return result;\n    }\n\n    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire\n    // data area of this QR Code. Function modules need to be marked off before this is called.\n  }, {\n    key: \"drawCodewords\",\n    value: function drawCodewords(data) {\n      if (data.length != Math.floor(QrCode.getNumRawDataModules(this.version) / 8)) throw new RangeError('Invalid argument');\n      var i = 0; // Bit index numbero the data\n      // Do the funny zigzag scan\n      for (var right = this.size - 1; right >= 1; right -= 2) {\n        // Index of right column in each column pair\n        if (right == 6) right = 5;\n        for (var vert = 0; vert < this.size; vert++) {\n          // Vertical counter\n          for (var j = 0; j < 2; j++) {\n            var x = right - j; // Actual x coordinate\n            var upward = (right + 1 & 2) == 0;\n            var y = upward ? this.size - 1 - vert : vert; // Actual y coordinate\n            if (!this.isFunction[y][x] && i < data.length * 8) {\n              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));\n              i++;\n            }\n            // If this QR Code has any remainder bits (0 to 7), they were assigned as\n            // 0/false/light by the constructor and are left unchanged by this method\n          }\n        }\n      }\n      assert(i == data.length * 8);\n    }\n\n    // XORs the codeword modules in this QR Code with the given mask pattern.\n    // The function modules must be marked and the codeword bits must be drawn\n    // before masking. Due to the arithmetic of XOR, calling applyMask() with\n    // the same mask value a second time will undo the mask. A final well-formed\n    // QR Code needs exactly one (not zero, two, etc.) mask applied.\n  }, {\n    key: \"applyMask\",\n    value: function applyMask(mask) {\n      if (mask < 0 || mask > 7) throw new RangeError('Mask value out of range');\n      for (var y = 0; y < this.size; y++) {\n        for (var x = 0; x < this.size; x++) {\n          var invert = void 0;\n          switch (mask) {\n            case 0:\n              invert = (x + y) % 2 == 0;\n              break;\n            case 1:\n              invert = y % 2 == 0;\n              break;\n            case 2:\n              invert = x % 3 == 0;\n              break;\n            case 3:\n              invert = (x + y) % 3 == 0;\n              break;\n            case 4:\n              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;\n              break;\n            case 5:\n              invert = x * y % 2 + x * y % 3 == 0;\n              break;\n            case 6:\n              invert = (x * y % 2 + x * y % 3) % 2 == 0;\n              break;\n            case 7:\n              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;\n              break;\n            default:\n              throw new Error('Unreachable');\n          }\n          if (!this.isFunction[y][x] && invert) this.modules[y][x] = !this.modules[y][x];\n        }\n      }\n    }\n\n    // Calculates and returns the penalty score based on state of this QR Code's current modules.\n    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.\n  }, {\n    key: \"getPenaltyScore\",\n    value: function getPenaltyScore() {\n      var result = 0;\n\n      // Adjacent modules in row having same color, and finder-like patterns\n      for (var y = 0; y < this.size; y++) {\n        var runColor = false;\n        var runX = 0;\n        var runHistory = [0, 0, 0, 0, 0, 0, 0];\n        for (var x = 0; x < this.size; x++) {\n          if (this.modules[y][x] == runColor) {\n            runX++;\n            if (runX == 5) result += QrCode.PENALTY_N1;else if (runX > 5) result++;\n          } else {\n            this.finderPenaltyAddHistory(runX, runHistory);\n            if (!runColor) result += this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;\n            runColor = this.modules[y][x];\n            runX = 1;\n          }\n        }\n        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * QrCode.PENALTY_N3;\n      }\n      // Adjacent modules in column having same color, and finder-like patterns\n      for (var _x = 0; _x < this.size; _x++) {\n        var _runColor = false;\n        var runY = 0;\n        var _runHistory = [0, 0, 0, 0, 0, 0, 0];\n        for (var _y = 0; _y < this.size; _y++) {\n          if (this.modules[_y][_x] == _runColor) {\n            runY++;\n            if (runY == 5) result += QrCode.PENALTY_N1;else if (runY > 5) result++;\n          } else {\n            this.finderPenaltyAddHistory(runY, _runHistory);\n            if (!_runColor) result += this.finderPenaltyCountPatterns(_runHistory) * QrCode.PENALTY_N3;\n            _runColor = this.modules[_y][_x];\n            runY = 1;\n          }\n        }\n        result += this.finderPenaltyTerminateAndCount(_runColor, runY, _runHistory) * QrCode.PENALTY_N3;\n      }\n\n      // 2*2 blocks of modules having same color\n      for (var _y2 = 0; _y2 < this.size - 1; _y2++) {\n        for (var _x2 = 0; _x2 < this.size - 1; _x2++) {\n          var color = this.modules[_y2][_x2];\n          if (color == this.modules[_y2][_x2 + 1] && color == this.modules[_y2 + 1][_x2] && color == this.modules[_y2 + 1][_x2 + 1]) result += QrCode.PENALTY_N2;\n        }\n      }\n\n      // Balance of dark and light modules\n      var dark = 0;\n      var _iterator3 = _createForOfIteratorHelper(this.modules),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var row = _step3.value;\n          dark = row.reduce(function (sum, color) {\n            return sum + (color ? 1 : 0);\n          }, dark);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      var total = this.size * this.size; // Note that size is odd, so dark/total != 1/2\n      // Compute the smallest numbereger k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%\n      var k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;\n      assert(0 <= k && k <= 9);\n      result += k * QrCode.PENALTY_N4;\n      assert(0 <= result && result <= 2568888); // Non-tight upper bound based on default values of PENALTY_N1, ..., N4\n      return result;\n    }\n\n    /*-- Private helper functions --*/\n\n    // Returns an ascending list of positions of alignment patterns for this version number.\n    // Each position is in the range [0,177), and are used on both the x and y axes.\n    // This could be implemented as lookup table of 40 variable-length lists of numberegers.\n  }, {\n    key: \"getAlignmentPatternPositions\",\n    value: function getAlignmentPatternPositions() {\n      if (this.version == 1) return [];else {\n        var numAlign = Math.floor(this.version / 7) + 2;\n        var step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;\n        var result = [6];\n        for (var pos = this.size - 7; result.length < numAlign; pos -= step) result.splice(1, 0, pos);\n        return result;\n      }\n    }\n\n    // Returns the number of data bits that can be stored in a QR Code of the given version number, after\n    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.\n    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.\n  }, {\n    key: \"finderPenaltyCountPatterns\",\n    value:\n    // Can only be called immediately after a light run is added, and\n    // returns either 0, 1, or 2. A helper function for getPenaltyScore().\n    function finderPenaltyCountPatterns(runHistory) {\n      var n = runHistory[1];\n      assert(n <= this.size * 3);\n      var core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;\n      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);\n    }\n\n    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().\n  }, {\n    key: \"finderPenaltyTerminateAndCount\",\n    value: function finderPenaltyTerminateAndCount(currentRunColor, oriCurrentRunLength, runHistory) {\n      var currentRunLength = oriCurrentRunLength;\n      if (currentRunColor) {\n        // Terminate dark run\n        this.finderPenaltyAddHistory(currentRunLength, runHistory);\n        currentRunLength = 0;\n      }\n      currentRunLength += this.size; // Add light border to final run\n      this.finderPenaltyAddHistory(currentRunLength, runHistory);\n      return this.finderPenaltyCountPatterns(runHistory);\n    }\n\n    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().\n  }, {\n    key: \"finderPenaltyAddHistory\",\n    value: function finderPenaltyAddHistory(oriCurrentRunLength, runHistory) {\n      var currentRunLength = oriCurrentRunLength;\n      if (runHistory[0] == 0) currentRunLength += this.size; // Add light border to initial run\n      runHistory.pop();\n      runHistory.unshift(currentRunLength);\n    }\n\n    /*-- Constants and tables --*/\n\n    // The minimum version number supported in the QR Code Model 2 standard.\n  }], [{\n    key: \"encodeText\",\n    value: /*-- Static factory functions (high level) --*/\n\n    // Returns a QR Code representing the given Unicode text string at the given error correction level.\n    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer\n    // Unicode code ponumbers (not UTF-16 code units) if the low error correction level is used. The smallest possible\n    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the\n    // ecl argument if it can be done without increasing the version.\n    function encodeText(text, ecl) {\n      var segs = QrSegment.makeSegments(text);\n      return QrCode.encodeSegments(segs, ecl);\n    }\n\n    // Returns a QR Code representing the given binary data at the given error correction level.\n    // This function always encodes using the binary segment mode, not any text mode. The maximum number of\n    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.\n    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.\n  }, {\n    key: \"encodeBinary\",\n    value: function encodeBinary(data, ecl) {\n      var seg = QrSegment.makeBytes(data);\n      return QrCode.encodeSegments([seg], ecl);\n    }\n\n    /*-- Static factory functions (mid level) --*/\n\n    // Returns a QR Code representing the given segments with the given encoding parameters.\n    // The smallest possible QR Code version within the given range is automatically\n    // chosen for the output. Iff boostEcl is true, then the ECC level of the result\n    // may be higher than the ecl argument if it can be done without increasing the\n    // version. The mask number is either between 0 to 7 (inclusive) to force that\n    // mask, or -1 to automatically choose an appropriate mask (which may be slow).\n    // This function allows the user to create a custom sequence of segments that switches\n    // between modes (such as alphanumeric and byte) to encode text in less space.\n    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().\n  }, {\n    key: \"encodeSegments\",\n    value: function encodeSegments(segs, oriEcl) {\n      var minVersion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      var maxVersion = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 40;\n      var mask = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n      var boostEcl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n      if (!(QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= QrCode.MAX_VERSION) || mask < -1 || mask > 7) throw new RangeError('Invalid value');\n\n      // Find the minimal version number to use\n      var version;\n      var dataUsedBits;\n      for (version = minVersion;; version++) {\n        var _dataCapacityBits = QrCode.getNumDataCodewords(version, oriEcl) * 8; // Number of data bits available\n        var usedBits = QrSegment.getTotalBits(segs, version);\n        if (usedBits <= _dataCapacityBits) {\n          dataUsedBits = usedBits;\n          break; // This version number is found to be suitable\n        }\n        if (version >= maxVersion)\n          // All versions in the range could not fit the given data\n          throw new RangeError('Data too long');\n      }\n      var ecl = oriEcl;\n      // Increase the error correction level while the data still fits in the current version number\n      for (var _i10 = 0, _arr = [Ecc.MEDIUM, Ecc.QUARTILE, Ecc.HIGH]; _i10 < _arr.length; _i10++) {\n        var newEcl = _arr[_i10];\n        // From low to high\n        if (boostEcl && dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8) ecl = newEcl;\n      }\n\n      // Concatenate all segments to create the data bit string\n      var bb = [];\n      var _iterator4 = _createForOfIteratorHelper(segs),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var seg = _step4.value;\n          appendBits(seg.mode.modeBits, 4, bb);\n          appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);\n          var _iterator5 = _createForOfIteratorHelper(seg.getData()),\n            _step5;\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var b = _step5.value;\n              bb.push(b);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      assert(bb.length == dataUsedBits);\n\n      // Add terminator and pad up to a byte if applicable\n      var dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;\n      assert(bb.length <= dataCapacityBits);\n      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);\n      appendBits(0, (8 - bb.length % 8) % 8, bb);\n      assert(bb.length % 8 == 0);\n\n      // Pad with alternating bytes until data capacity is reached\n      for (var padByte = 0xec; bb.length < dataCapacityBits; padByte ^= 0xec ^ 0x11) appendBits(padByte, 8, bb);\n\n      // Pack bits numbero bytes in big endian\n      var dataCodewords = [];\n      while (dataCodewords.length * 8 < bb.length) dataCodewords.push(0);\n      bb.forEach(function (b, i) {\n        return dataCodewords[i >>> 3] |= b << 7 - (i & 7);\n      });\n\n      // Create the QR Code object\n      return new QrCode(version, ecl, dataCodewords, mask);\n    }\n  }, {\n    key: \"getNumRawDataModules\",\n    value: function getNumRawDataModules(ver) {\n      if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION) throw new RangeError('Version number out of range');\n      var result = (16 * ver + 128) * ver + 64;\n      if (ver >= 2) {\n        var numAlign = Math.floor(ver / 7) + 2;\n        result -= (25 * numAlign - 10) * numAlign - 55;\n        if (ver >= 7) result -= 36;\n      }\n      assert(208 <= result && result <= 29648);\n      return result;\n    }\n\n    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any\n    // QR Code of the given version number and error correction level, with remainder bits discarded.\n    // This stateless pure function could be implemented as a (40*4)-cell lookup table.\n  }, {\n    key: \"getNumDataCodewords\",\n    value: function getNumDataCodewords(ver, ecl) {\n      return Math.floor(QrCode.getNumRawDataModules(ver) / 8) - QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];\n    }\n\n    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be\n    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.\n  }, {\n    key: \"reedSolomonComputeDivisor\",\n    value: function reedSolomonComputeDivisor(degree) {\n      if (degree < 1 || degree > 255) throw new RangeError('Degree out of range');\n      // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.\n      // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the unumber8 array [255, 8, 93].\n      var result = [];\n      for (var i = 0; i < degree - 1; i++) result.push(0);\n      result.push(1); // Start off with the monomial x^0\n\n      // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),\n      // and drop the highest monomial term which is always 1x^degree.\n      // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).\n      var root = 1;\n      for (var _i11 = 0; _i11 < degree; _i11++) {\n        // Multiply the current product by (x - r^i)\n        for (var j = 0; j < result.length; j++) {\n          result[j] = QrCode.reedSolomonMultiply(result[j], root);\n          if (j + 1 < result.length) result[j] ^= result[j + 1];\n        }\n        root = QrCode.reedSolomonMultiply(root, 0x02);\n      }\n      return result;\n    }\n\n    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.\n  }, {\n    key: \"reedSolomonComputeRemainder\",\n    value: function reedSolomonComputeRemainder(data, divisor) {\n      var result = divisor.map(function () {\n        return 0;\n      });\n      var _iterator6 = _createForOfIteratorHelper(data),\n        _step6;\n      try {\n        var _loop2 = function _loop2() {\n          var b = _step6.value;\n          // Polynomial division\n          var factor = b ^ result.shift();\n          result.push(0);\n          divisor.forEach(function (coef, i) {\n            return result[i] ^= QrCode.reedSolomonMultiply(coef, factor);\n          });\n        };\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          _loop2();\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return result;\n    }\n\n    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result\n    // are unsigned 8-bit numberegers. This could be implemented as a lookup table of 256*256 entries of unumber8.\n  }, {\n    key: \"reedSolomonMultiply\",\n    value: function reedSolomonMultiply(x, y) {\n      if (x >>> 8 != 0 || y >>> 8 != 0) throw new RangeError('Byte out of range');\n      // Russian peasant multiplication\n      var z = 0;\n      for (var i = 7; i >= 0; i--) {\n        z = z << 1 ^ (z >>> 7) * 0x11d;\n        z ^= (y >>> i & 1) * x;\n      }\n      assert(z >>> 8 == 0);\n      return z;\n    }\n  }]);\n  return QrCode;\n}();\n_defineProperty(QrCode, \"MIN_VERSION\", 1);\n// The maximum version number supported in the QR Code Model 2 standard.\n_defineProperty(QrCode, \"MAX_VERSION\", 40);\n// For use in getPenaltyScore(), when evaluating which mask is best.\n_defineProperty(QrCode, \"PENALTY_N1\", 3);\n_defineProperty(QrCode, \"PENALTY_N2\", 3);\n_defineProperty(QrCode, \"PENALTY_N3\", 40);\n_defineProperty(QrCode, \"PENALTY_N4\", 10);\n_defineProperty(QrCode, \"ECC_CODEWORDS_PER_BLOCK\", [\n// Version: (note that index 0 is for padding, and is set to an illegal value)\n//0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n[-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n// Low\n[-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n// Medium\n[-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n// Quartile\n[-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30] // High\n]);\n_defineProperty(QrCode, \"NUM_ERROR_CORRECTION_BLOCKS\", [\n// Version: (note that index 0 is for padding, and is set to an illegal value)\n//0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level\n[-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n// Low\n[-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n// Medium\n[-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n// Quartile\n[-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81] // High\n]);"]},"metadata":{},"sourceType":"module"}