{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEvent } from 'rc-util';\nimport useState from \"rc-util/es/hooks/useState\";\nimport useSyncState from \"rc-util/es/hooks/useSyncState\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { STATUS_APPEAR, STATUS_ENTER, STATUS_LEAVE, STATUS_NONE, STEP_ACTIVE, STEP_PREPARE, STEP_PREPARED, STEP_START } from \"../interface\";\nimport useDomMotionEvents from \"./useDomMotionEvents\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStepQueue, { DoStep, isActive, SkipStep } from \"./useStepQueue\";\nexport default function useStatus(supportMotion, visible, getElement, _ref) {\n  var _ref$motionEnter = _ref.motionEnter,\n      motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,\n      _ref$motionAppear = _ref.motionAppear,\n      motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,\n      _ref$motionLeave = _ref.motionLeave,\n      motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,\n      motionDeadline = _ref.motionDeadline,\n      motionLeaveImmediately = _ref.motionLeaveImmediately,\n      onAppearPrepare = _ref.onAppearPrepare,\n      onEnterPrepare = _ref.onEnterPrepare,\n      onLeavePrepare = _ref.onLeavePrepare,\n      onAppearStart = _ref.onAppearStart,\n      onEnterStart = _ref.onEnterStart,\n      onLeaveStart = _ref.onLeaveStart,\n      onAppearActive = _ref.onAppearActive,\n      onEnterActive = _ref.onEnterActive,\n      onLeaveActive = _ref.onLeaveActive,\n      onAppearEnd = _ref.onAppearEnd,\n      onEnterEnd = _ref.onEnterEnd,\n      onLeaveEnd = _ref.onLeaveEnd,\n      onVisibleChanged = _ref.onVisibleChanged; // Used for outer render usage to avoid `visible: false & status: none` to render nothing\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      asyncVisible = _useState2[0],\n      setAsyncVisible = _useState2[1];\n\n  var _useSyncState = useSyncState(STATUS_NONE),\n      _useSyncState2 = _slicedToArray(_useSyncState, 2),\n      getStatus = _useSyncState2[0],\n      setStatus = _useSyncState2[1];\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      style = _useState4[0],\n      setStyle = _useState4[1];\n\n  var currentStatus = getStatus();\n  var mountedRef = useRef(false);\n  var deadlineRef = useRef(null); // =========================== Dom Node ===========================\n\n  function getDomElement() {\n    return getElement();\n  } // ========================== Motion End ==========================\n\n\n  var activeRef = useRef(false);\n  /**\n   * Clean up status & style\n   */\n\n  function updateMotionEndStatus() {\n    setStatus(STATUS_NONE);\n    setStyle(null, true);\n  }\n\n  var onInternalMotionEnd = useEvent(function (event) {\n    var status = getStatus(); // Do nothing since not in any transition status.\n    // This may happen when `motionDeadline` trigger.\n\n    if (status === STATUS_NONE) {\n      return;\n    }\n\n    var element = getDomElement();\n\n    if (event && !event.deadline && event.target !== element) {\n      // event exists\n      // not initiated by deadline\n      // transitionEnd not fired by inner elements\n      return;\n    }\n\n    var currentActive = activeRef.current;\n    var canEnd;\n\n    if (status === STATUS_APPEAR && currentActive) {\n      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);\n    } else if (status === STATUS_ENTER && currentActive) {\n      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);\n    } else if (status === STATUS_LEAVE && currentActive) {\n      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);\n    } // Only update status when `canEnd` and not destroyed\n\n\n    if (currentActive && canEnd !== false) {\n      updateMotionEndStatus();\n    }\n  });\n\n  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),\n      _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1),\n      patchMotionEvents = _useDomMotionEvents2[0]; // ============================= Step =============================\n\n\n  var getEventHandlers = function getEventHandlers(targetStatus) {\n    switch (targetStatus) {\n      case STATUS_APPEAR:\n        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);\n\n      case STATUS_ENTER:\n        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);\n\n      case STATUS_LEAVE:\n        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);\n\n      default:\n        return {};\n    }\n  };\n\n  var eventHandlers = React.useMemo(function () {\n    return getEventHandlers(currentStatus);\n  }, [currentStatus]);\n\n  var _useStepQueue = useStepQueue(currentStatus, !supportMotion, function (newStep) {\n    // Only prepare step can be skip\n    if (newStep === STEP_PREPARE) {\n      var onPrepare = eventHandlers[STEP_PREPARE];\n\n      if (!onPrepare) {\n        return SkipStep;\n      }\n\n      return onPrepare(getDomElement());\n    } // Rest step is sync update\n\n\n    if (step in eventHandlers) {\n      var _eventHandlers$step;\n\n      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);\n    }\n\n    if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {\n      // Patch events when motion needed\n      patchMotionEvents(getDomElement());\n\n      if (motionDeadline > 0) {\n        clearTimeout(deadlineRef.current);\n        deadlineRef.current = setTimeout(function () {\n          onInternalMotionEnd({\n            deadline: true\n          });\n        }, motionDeadline);\n      }\n    }\n\n    if (step === STEP_PREPARED) {\n      updateMotionEndStatus();\n    }\n\n    return DoStep;\n  }),\n      _useStepQueue2 = _slicedToArray(_useStepQueue, 2),\n      startStep = _useStepQueue2[0],\n      step = _useStepQueue2[1];\n\n  var active = isActive(step);\n  activeRef.current = active; // ============================ Status ============================\n\n  var visibleRef = useRef(null); // Update with new status\n\n  useIsomorphicLayoutEffect(function () {\n    // When use Suspense, the `visible` will repeat trigger,\n    // But not real change of the `visible`, we need to skip it.\n    // https://github.com/ant-design/ant-design/issues/44379\n    if (mountedRef.current && visibleRef.current === visible) {\n      return;\n    }\n\n    setAsyncVisible(visible);\n    var isMounted = mountedRef.current;\n    mountedRef.current = true; // if (!supportMotion) {\n    //   return;\n    // }\n\n    var nextStatus; // Appear\n\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    } // Enter\n\n\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    } // Leave\n\n\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n\n    var nextEventHandlers = getEventHandlers(nextStatus); // Update to next status\n\n    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {\n      setStatus(nextStatus);\n      startStep();\n    } else {\n      // Set back in case no motion but prev status has prepare step\n      setStatus(STATUS_NONE);\n    }\n\n    visibleRef.current = visible;\n  }, [visible]); // ============================ Effect ============================\n  // Reset when motion changed\n\n  useEffect(function () {\n    if ( // Cancel appear\n    currentStatus === STATUS_APPEAR && !motionAppear || // Cancel enter\n    currentStatus === STATUS_ENTER && !motionEnter || // Cancel leave\n    currentStatus === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  useEffect(function () {\n    return function () {\n      mountedRef.current = false;\n      clearTimeout(deadlineRef.current);\n    };\n  }, []); // Trigger `onVisibleChanged`\n\n  var firstMountChangeRef = React.useRef(false);\n  useEffect(function () {\n    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged\n    if (asyncVisible) {\n      firstMountChangeRef.current = true;\n    }\n\n    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {\n      // Skip first render is invisible since it's nothing changed\n      if (firstMountChangeRef.current || asyncVisible) {\n        onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);\n      }\n\n      firstMountChangeRef.current = true;\n    }\n  }, [asyncVisible, currentStatus]); // ============================ Styles ============================\n\n  var mergedStyle = style;\n\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = _objectSpread({\n      transition: 'none'\n    }, mergedStyle);\n  }\n\n  return [currentStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];\n}","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/rc-motion/es/hooks/useStatus.js"],"names":["_objectSpread","_defineProperty","_slicedToArray","useEvent","useState","useSyncState","React","useEffect","useRef","STATUS_APPEAR","STATUS_ENTER","STATUS_LEAVE","STATUS_NONE","STEP_ACTIVE","STEP_PREPARE","STEP_PREPARED","STEP_START","useDomMotionEvents","useIsomorphicLayoutEffect","useStepQueue","DoStep","isActive","SkipStep","useStatus","supportMotion","visible","getElement","_ref","_ref$motionEnter","motionEnter","_ref$motionAppear","motionAppear","_ref$motionLeave","motionLeave","motionDeadline","motionLeaveImmediately","onAppearPrepare","onEnterPrepare","onLeavePrepare","onAppearStart","onEnterStart","onLeaveStart","onAppearActive","onEnterActive","onLeaveActive","onAppearEnd","onEnterEnd","onLeaveEnd","onVisibleChanged","_useState","_useState2","asyncVisible","setAsyncVisible","_useSyncState","_useSyncState2","getStatus","setStatus","_useState3","_useState4","style","setStyle","currentStatus","mountedRef","deadlineRef","getDomElement","activeRef","updateMotionEndStatus","onInternalMotionEnd","event","status","element","deadline","target","currentActive","current","canEnd","_useDomMotionEvents","_useDomMotionEvents2","patchMotionEvents","getEventHandlers","targetStatus","eventHandlers","useMemo","_useStepQueue","newStep","onPrepare","step","_eventHandlers$step","call","clearTimeout","setTimeout","_useStepQueue2","startStep","active","visibleRef","isMounted","nextStatus","nextEventHandlers","firstMountChangeRef","undefined","mergedStyle","transition"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEvent } from 'rc-util';\nimport useState from \"rc-util/es/hooks/useState\";\nimport useSyncState from \"rc-util/es/hooks/useSyncState\";\nimport * as React from 'react';\nimport { useEffect, useRef } from 'react';\nimport { STATUS_APPEAR, STATUS_ENTER, STATUS_LEAVE, STATUS_NONE, STEP_ACTIVE, STEP_PREPARE, STEP_PREPARED, STEP_START } from \"../interface\";\nimport useDomMotionEvents from \"./useDomMotionEvents\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicLayoutEffect\";\nimport useStepQueue, { DoStep, isActive, SkipStep } from \"./useStepQueue\";\nexport default function useStatus(supportMotion, visible, getElement, _ref) {\n  var _ref$motionEnter = _ref.motionEnter,\n    motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,\n    _ref$motionAppear = _ref.motionAppear,\n    motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,\n    _ref$motionLeave = _ref.motionLeave,\n    motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,\n    motionDeadline = _ref.motionDeadline,\n    motionLeaveImmediately = _ref.motionLeaveImmediately,\n    onAppearPrepare = _ref.onAppearPrepare,\n    onEnterPrepare = _ref.onEnterPrepare,\n    onLeavePrepare = _ref.onLeavePrepare,\n    onAppearStart = _ref.onAppearStart,\n    onEnterStart = _ref.onEnterStart,\n    onLeaveStart = _ref.onLeaveStart,\n    onAppearActive = _ref.onAppearActive,\n    onEnterActive = _ref.onEnterActive,\n    onLeaveActive = _ref.onLeaveActive,\n    onAppearEnd = _ref.onAppearEnd,\n    onEnterEnd = _ref.onEnterEnd,\n    onLeaveEnd = _ref.onLeaveEnd,\n    onVisibleChanged = _ref.onVisibleChanged;\n  // Used for outer render usage to avoid `visible: false & status: none` to render nothing\n  var _useState = useState(),\n    _useState2 = _slicedToArray(_useState, 2),\n    asyncVisible = _useState2[0],\n    setAsyncVisible = _useState2[1];\n  var _useSyncState = useSyncState(STATUS_NONE),\n    _useSyncState2 = _slicedToArray(_useSyncState, 2),\n    getStatus = _useSyncState2[0],\n    setStatus = _useSyncState2[1];\n  var _useState3 = useState(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    style = _useState4[0],\n    setStyle = _useState4[1];\n  var currentStatus = getStatus();\n  var mountedRef = useRef(false);\n  var deadlineRef = useRef(null);\n\n  // =========================== Dom Node ===========================\n  function getDomElement() {\n    return getElement();\n  }\n\n  // ========================== Motion End ==========================\n  var activeRef = useRef(false);\n\n  /**\n   * Clean up status & style\n   */\n  function updateMotionEndStatus() {\n    setStatus(STATUS_NONE);\n    setStyle(null, true);\n  }\n  var onInternalMotionEnd = useEvent(function (event) {\n    var status = getStatus();\n    // Do nothing since not in any transition status.\n    // This may happen when `motionDeadline` trigger.\n    if (status === STATUS_NONE) {\n      return;\n    }\n    var element = getDomElement();\n    if (event && !event.deadline && event.target !== element) {\n      // event exists\n      // not initiated by deadline\n      // transitionEnd not fired by inner elements\n      return;\n    }\n    var currentActive = activeRef.current;\n    var canEnd;\n    if (status === STATUS_APPEAR && currentActive) {\n      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);\n    } else if (status === STATUS_ENTER && currentActive) {\n      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);\n    } else if (status === STATUS_LEAVE && currentActive) {\n      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);\n    }\n\n    // Only update status when `canEnd` and not destroyed\n    if (currentActive && canEnd !== false) {\n      updateMotionEndStatus();\n    }\n  });\n  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),\n    _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1),\n    patchMotionEvents = _useDomMotionEvents2[0];\n\n  // ============================= Step =============================\n  var getEventHandlers = function getEventHandlers(targetStatus) {\n    switch (targetStatus) {\n      case STATUS_APPEAR:\n        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);\n      case STATUS_ENTER:\n        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);\n      case STATUS_LEAVE:\n        return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);\n      default:\n        return {};\n    }\n  };\n  var eventHandlers = React.useMemo(function () {\n    return getEventHandlers(currentStatus);\n  }, [currentStatus]);\n  var _useStepQueue = useStepQueue(currentStatus, !supportMotion, function (newStep) {\n      // Only prepare step can be skip\n      if (newStep === STEP_PREPARE) {\n        var onPrepare = eventHandlers[STEP_PREPARE];\n        if (!onPrepare) {\n          return SkipStep;\n        }\n        return onPrepare(getDomElement());\n      }\n\n      // Rest step is sync update\n      if (step in eventHandlers) {\n        var _eventHandlers$step;\n        setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);\n      }\n      if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {\n        // Patch events when motion needed\n        patchMotionEvents(getDomElement());\n        if (motionDeadline > 0) {\n          clearTimeout(deadlineRef.current);\n          deadlineRef.current = setTimeout(function () {\n            onInternalMotionEnd({\n              deadline: true\n            });\n          }, motionDeadline);\n        }\n      }\n      if (step === STEP_PREPARED) {\n        updateMotionEndStatus();\n      }\n      return DoStep;\n    }),\n    _useStepQueue2 = _slicedToArray(_useStepQueue, 2),\n    startStep = _useStepQueue2[0],\n    step = _useStepQueue2[1];\n  var active = isActive(step);\n  activeRef.current = active;\n\n  // ============================ Status ============================\n  var visibleRef = useRef(null);\n\n  // Update with new status\n  useIsomorphicLayoutEffect(function () {\n    // When use Suspense, the `visible` will repeat trigger,\n    // But not real change of the `visible`, we need to skip it.\n    // https://github.com/ant-design/ant-design/issues/44379\n    if (mountedRef.current && visibleRef.current === visible) {\n      return;\n    }\n    setAsyncVisible(visible);\n    var isMounted = mountedRef.current;\n    mountedRef.current = true;\n\n    // if (!supportMotion) {\n    //   return;\n    // }\n\n    var nextStatus;\n\n    // Appear\n    if (!isMounted && visible && motionAppear) {\n      nextStatus = STATUS_APPEAR;\n    }\n\n    // Enter\n    if (isMounted && visible && motionEnter) {\n      nextStatus = STATUS_ENTER;\n    }\n\n    // Leave\n    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {\n      nextStatus = STATUS_LEAVE;\n    }\n    var nextEventHandlers = getEventHandlers(nextStatus);\n\n    // Update to next status\n    if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {\n      setStatus(nextStatus);\n      startStep();\n    } else {\n      // Set back in case no motion but prev status has prepare step\n      setStatus(STATUS_NONE);\n    }\n    visibleRef.current = visible;\n  }, [visible]);\n\n  // ============================ Effect ============================\n  // Reset when motion changed\n  useEffect(function () {\n    if (\n    // Cancel appear\n    currentStatus === STATUS_APPEAR && !motionAppear ||\n    // Cancel enter\n    currentStatus === STATUS_ENTER && !motionEnter ||\n    // Cancel leave\n    currentStatus === STATUS_LEAVE && !motionLeave) {\n      setStatus(STATUS_NONE);\n    }\n  }, [motionAppear, motionEnter, motionLeave]);\n  useEffect(function () {\n    return function () {\n      mountedRef.current = false;\n      clearTimeout(deadlineRef.current);\n    };\n  }, []);\n\n  // Trigger `onVisibleChanged`\n  var firstMountChangeRef = React.useRef(false);\n  useEffect(function () {\n    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged\n    if (asyncVisible) {\n      firstMountChangeRef.current = true;\n    }\n    if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {\n      // Skip first render is invisible since it's nothing changed\n      if (firstMountChangeRef.current || asyncVisible) {\n        onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);\n      }\n      firstMountChangeRef.current = true;\n    }\n  }, [asyncVisible, currentStatus]);\n\n  // ============================ Styles ============================\n  var mergedStyle = style;\n  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {\n    mergedStyle = _objectSpread({\n      transition: 'none'\n    }, mergedStyle);\n  }\n  return [currentStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];\n}"]},"metadata":{},"sourceType":"module"}