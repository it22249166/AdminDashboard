{"ast":null,"code":"import * as React from 'react';\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useMergedState from \"rc-util/es/hooks/useMergedState\";\nimport { useLocale } from '../../locale';\nimport { generateColor } from '../util';\n/**\n * Combine the `color` and `mode` to make sure sync of state.\n */\n\nexport default function useModeColor(defaultValue, value, mode) {\n  const [locale] = useLocale('ColorPicker'); // ======================== Base ========================\n  // Color\n\n  const [mergedColor, setMergedColor] = useMergedState(defaultValue, {\n    value\n  }); // Mode\n\n  const [modeState, setModeState] = React.useState('single');\n  const [modeOptionList, modeSet] = React.useMemo(() => {\n    const list = (Array.isArray(mode) ? mode : [mode]).filter(m => m);\n\n    if (!list.length) {\n      list.push('single');\n    }\n\n    const modes = new Set(list);\n    const optionList = [];\n\n    const pushOption = (modeType, localeTxt) => {\n      if (modes.has(modeType)) {\n        optionList.push({\n          label: localeTxt,\n          value: modeType\n        });\n      }\n    };\n\n    pushOption('single', locale.singleColor);\n    pushOption('gradient', locale.gradientColor);\n    return [optionList, modes];\n  }, [mode]); // ======================== Post ========================\n  // We need align `mode` with `color` state\n  // >>>>> Color\n\n  const [cacheColor, setCacheColor] = React.useState(null);\n  const setColor = useEvent(nextColor => {\n    setCacheColor(nextColor);\n    setMergedColor(nextColor);\n  });\n  const postColor = React.useMemo(() => {\n    const colorObj = generateColor(mergedColor || ''); // Use `cacheColor` in case the color is `cleared`\n\n    return colorObj.equals(cacheColor) ? cacheColor : colorObj;\n  }, [mergedColor, cacheColor]); // >>>>> Mode\n\n  const postMode = React.useMemo(() => {\n    var _a;\n\n    if (modeSet.has(modeState)) {\n      return modeState;\n    }\n\n    return (_a = modeOptionList[0]) === null || _a === void 0 ? void 0 : _a.value;\n  }, [modeSet, modeState, modeOptionList]); // ======================= Effect =======================\n  // Dynamic update mode when color change\n\n  React.useEffect(() => {\n    setModeState(postColor.isGradient() ? 'gradient' : 'single');\n  }, [postColor]); // ======================= Return =======================\n\n  return [postColor, setColor, postMode, setModeState, modeOptionList];\n}","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/color-picker/hooks/useModeColor.js"],"names":["React","useEvent","useMergedState","useLocale","generateColor","useModeColor","defaultValue","value","mode","locale","mergedColor","setMergedColor","modeState","setModeState","useState","modeOptionList","modeSet","useMemo","list","Array","isArray","filter","m","length","push","modes","Set","optionList","pushOption","modeType","localeTxt","has","label","singleColor","gradientColor","cacheColor","setCacheColor","setColor","nextColor","postColor","colorObj","equals","postMode","_a","useEffect","isGradient"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useMergedState from \"rc-util/es/hooks/useMergedState\";\nimport { useLocale } from '../../locale';\nimport { generateColor } from '../util';\n/**\n * Combine the `color` and `mode` to make sure sync of state.\n */\nexport default function useModeColor(defaultValue, value, mode) {\n  const [locale] = useLocale('ColorPicker');\n  // ======================== Base ========================\n  // Color\n  const [mergedColor, setMergedColor] = useMergedState(defaultValue, {\n    value\n  });\n  // Mode\n  const [modeState, setModeState] = React.useState('single');\n  const [modeOptionList, modeSet] = React.useMemo(() => {\n    const list = (Array.isArray(mode) ? mode : [mode]).filter(m => m);\n    if (!list.length) {\n      list.push('single');\n    }\n    const modes = new Set(list);\n    const optionList = [];\n    const pushOption = (modeType, localeTxt) => {\n      if (modes.has(modeType)) {\n        optionList.push({\n          label: localeTxt,\n          value: modeType\n        });\n      }\n    };\n    pushOption('single', locale.singleColor);\n    pushOption('gradient', locale.gradientColor);\n    return [optionList, modes];\n  }, [mode]);\n  // ======================== Post ========================\n  // We need align `mode` with `color` state\n  // >>>>> Color\n  const [cacheColor, setCacheColor] = React.useState(null);\n  const setColor = useEvent(nextColor => {\n    setCacheColor(nextColor);\n    setMergedColor(nextColor);\n  });\n  const postColor = React.useMemo(() => {\n    const colorObj = generateColor(mergedColor || '');\n    // Use `cacheColor` in case the color is `cleared`\n    return colorObj.equals(cacheColor) ? cacheColor : colorObj;\n  }, [mergedColor, cacheColor]);\n  // >>>>> Mode\n  const postMode = React.useMemo(() => {\n    var _a;\n    if (modeSet.has(modeState)) {\n      return modeState;\n    }\n    return (_a = modeOptionList[0]) === null || _a === void 0 ? void 0 : _a.value;\n  }, [modeSet, modeState, modeOptionList]);\n  // ======================= Effect =======================\n  // Dynamic update mode when color change\n  React.useEffect(() => {\n    setModeState(postColor.isGradient() ? 'gradient' : 'single');\n  }, [postColor]);\n  // ======================= Return =======================\n  return [postColor, setColor, postMode, setModeState, modeOptionList];\n}"]},"metadata":{},"sourceType":"module"}