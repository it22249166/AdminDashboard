{"ast":null,"code":"import * as React from 'react';\nexport default function useResizable(items, pxSizes, isRTL) {\n  return React.useMemo(() => {\n    const resizeInfos = [];\n\n    for (let i = 0; i < items.length - 1; i += 1) {\n      const prevItem = items[i];\n      const nextItem = items[i + 1];\n      const prevSize = pxSizes[i];\n      const nextSize = pxSizes[i + 1];\n      const {\n        resizable: prevResizable = true,\n        min: prevMin,\n        collapsible: prevCollapsible\n      } = prevItem;\n      const {\n        resizable: nextResizable = true,\n        min: nextMin,\n        collapsible: nextCollapsible\n      } = nextItem;\n      const mergedResizable = // Both need to be resizable\n      prevResizable && nextResizable && ( // Prev is not collapsed and limit min size\n      prevSize !== 0 || !prevMin) && ( // Next is not collapsed and limit min size\n      nextSize !== 0 || !nextMin);\n      const startCollapsible = // Self is collapsible\n      prevCollapsible.end && prevSize > 0 || // Collapsed and can be collapsed\n      nextCollapsible.start && nextSize === 0 && prevSize > 0;\n      const endCollapsible = // Self is collapsible\n      nextCollapsible.start && nextSize > 0 || // Collapsed and can be collapsed\n      prevCollapsible.end && prevSize === 0 && nextSize > 0;\n      resizeInfos[i] = {\n        resizable: mergedResizable,\n        startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),\n        endCollapsible: !!(isRTL ? startCollapsible : endCollapsible)\n      };\n    }\n\n    return resizeInfos;\n  }, [pxSizes, items]);\n}","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/splitter/hooks/useResizable.js"],"names":["React","useResizable","items","pxSizes","isRTL","useMemo","resizeInfos","i","length","prevItem","nextItem","prevSize","nextSize","resizable","prevResizable","min","prevMin","collapsible","prevCollapsible","nextResizable","nextMin","nextCollapsible","mergedResizable","startCollapsible","end","start","endCollapsible"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,eAAe,SAASC,YAAT,CAAsBC,KAAtB,EAA6BC,OAA7B,EAAsCC,KAAtC,EAA6C;AAC1D,SAAOJ,KAAK,CAACK,OAAN,CAAc,MAAM;AACzB,UAAMC,WAAW,GAAG,EAApB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACM,MAAN,GAAe,CAAnC,EAAsCD,CAAC,IAAI,CAA3C,EAA8C;AAC5C,YAAME,QAAQ,GAAGP,KAAK,CAACK,CAAD,CAAtB;AACA,YAAMG,QAAQ,GAAGR,KAAK,CAACK,CAAC,GAAG,CAAL,CAAtB;AACA,YAAMI,QAAQ,GAAGR,OAAO,CAACI,CAAD,CAAxB;AACA,YAAMK,QAAQ,GAAGT,OAAO,CAACI,CAAC,GAAG,CAAL,CAAxB;AACA,YAAM;AACJM,QAAAA,SAAS,EAAEC,aAAa,GAAG,IADvB;AAEJC,QAAAA,GAAG,EAAEC,OAFD;AAGJC,QAAAA,WAAW,EAAEC;AAHT,UAIFT,QAJJ;AAKA,YAAM;AACJI,QAAAA,SAAS,EAAEM,aAAa,GAAG,IADvB;AAEJJ,QAAAA,GAAG,EAAEK,OAFD;AAGJH,QAAAA,WAAW,EAAEI;AAHT,UAIFX,QAJJ;AAKA,YAAMY,eAAe,GACrB;AACAR,MAAAA,aAAa,IAAIK,aAAjB,MACA;AACAR,MAAAA,QAAQ,KAAK,CAAb,IAAkB,CAACK,OAFnB,OAGA;AACAJ,MAAAA,QAAQ,KAAK,CAAb,IAAkB,CAACQ,OAJnB,CAFA;AAOA,YAAMG,gBAAgB,GACtB;AACAL,MAAAA,eAAe,CAACM,GAAhB,IAAuBb,QAAQ,GAAG,CAAlC,IACA;AACAU,MAAAA,eAAe,CAACI,KAAhB,IAAyBb,QAAQ,KAAK,CAAtC,IAA2CD,QAAQ,GAAG,CAJtD;AAKA,YAAMe,cAAc,GACpB;AACAL,MAAAA,eAAe,CAACI,KAAhB,IAAyBb,QAAQ,GAAG,CAApC,IACA;AACAM,MAAAA,eAAe,CAACM,GAAhB,IAAuBb,QAAQ,KAAK,CAApC,IAAyCC,QAAQ,GAAG,CAJpD;AAKAN,MAAAA,WAAW,CAACC,CAAD,CAAX,GAAiB;AACfM,QAAAA,SAAS,EAAES,eADI;AAEfC,QAAAA,gBAAgB,EAAE,CAAC,EAAEnB,KAAK,GAAGsB,cAAH,GAAoBH,gBAA3B,CAFJ;AAGfG,QAAAA,cAAc,EAAE,CAAC,EAAEtB,KAAK,GAAGmB,gBAAH,GAAsBG,cAA7B;AAHF,OAAjB;AAKD;;AACD,WAAOpB,WAAP;AACD,GAzCM,EAyCJ,CAACH,OAAD,EAAUD,KAAV,CAzCI,CAAP;AA0CD","sourcesContent":["import * as React from 'react';\nexport default function useResizable(items, pxSizes, isRTL) {\n  return React.useMemo(() => {\n    const resizeInfos = [];\n    for (let i = 0; i < items.length - 1; i += 1) {\n      const prevItem = items[i];\n      const nextItem = items[i + 1];\n      const prevSize = pxSizes[i];\n      const nextSize = pxSizes[i + 1];\n      const {\n        resizable: prevResizable = true,\n        min: prevMin,\n        collapsible: prevCollapsible\n      } = prevItem;\n      const {\n        resizable: nextResizable = true,\n        min: nextMin,\n        collapsible: nextCollapsible\n      } = nextItem;\n      const mergedResizable =\n      // Both need to be resizable\n      prevResizable && nextResizable && (\n      // Prev is not collapsed and limit min size\n      prevSize !== 0 || !prevMin) && (\n      // Next is not collapsed and limit min size\n      nextSize !== 0 || !nextMin);\n      const startCollapsible =\n      // Self is collapsible\n      prevCollapsible.end && prevSize > 0 ||\n      // Collapsed and can be collapsed\n      nextCollapsible.start && nextSize === 0 && prevSize > 0;\n      const endCollapsible =\n      // Self is collapsible\n      nextCollapsible.start && nextSize > 0 ||\n      // Collapsed and can be collapsed\n      prevCollapsible.end && prevSize === 0 && nextSize > 0;\n      resizeInfos[i] = {\n        resizable: mergedResizable,\n        startCollapsible: !!(isRTL ? endCollapsible : startCollapsible),\n        endCollapsible: !!(isRTL ? startCollapsible : endCollapsible)\n      };\n    }\n    return resizeInfos;\n  }, [pxSizes, items]);\n}"]},"metadata":{},"sourceType":"module"}