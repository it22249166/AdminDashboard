{"ast":null,"code":"\"use client\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React from 'react';\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\n\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\n\nconst AFFIX_STATUS_NONE = 0;\nconst AFFIX_STATUS_PREPARE = 1;\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _a;\n\n  const {\n    style,\n    offsetTop,\n    offsetBottom,\n    prefixCls,\n    className,\n    rootClassName,\n    children,\n    target,\n    onChange,\n    onTestUpdatePosition\n  } = props,\n        restProps = __rest(props, [\"style\", \"offsetTop\", \"offsetBottom\", \"prefixCls\", \"className\", \"rootClassName\", \"children\", \"target\", \"onChange\", \"onTestUpdatePosition\"]);\n\n  const {\n    getPrefixCls,\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', prefixCls);\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AFFIX_STATUS_NONE);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef(null);\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop; // =================== Measure ===================\n\n  const measure = () => {\n    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n\n    const targetNode = targetFunc();\n\n    if (targetNode) {\n      const newState = {\n        status: AFFIX_STATUS_NONE\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n\n      newState.lastAffix = !!newState.affixStyle;\n\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);\n      }\n\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n\n  const prepareMeasure = () => {\n    status.current = AFFIX_STATUS_PREPARE;\n    measure();\n\n    if (process.env.NODE_ENV === 'test') {\n      onTestUpdatePosition === null || onTestUpdatePosition === void 0 ? void 0 : onTestUpdatePosition();\n    }\n  };\n\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    } // Directly call prepare measure since it's already throttled.\n\n\n    prepareMeasure();\n  });\n\n  const addListeners = () => {\n    const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n\n    if (!listenerTarget) {\n      return;\n    }\n\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n\n      listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n\n  const removeListeners = () => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n\n    const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n\n      newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);\n\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  })); // mount & unmount\n\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => removeListeners();\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n    return () => removeListeners();\n  }, [target, affixStyle, lastAffix, offsetTop, offsetBottom]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(affixPrefixCls);\n  const rootCls = classNames(rootClassName, hashId, affixPrefixCls, cssVarCls);\n  const mergedCls = classNames({\n    [rootCls]: affixStyle\n  });\n  return wrapCSSVar( /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: style,\n    className: className,\n    ref: placeholderNodeRef\n  }, restProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: mergedCls,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children)))));\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\n\nexport default Affix;","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/antd/es/affix/index.js"],"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","React","classNames","ResizeObserver","throttleByAnimationFrame","ConfigContext","useStyle","getFixedBottom","getFixedTop","getTargetRect","TRIGGER_EVENTS","getDefaultTarget","window","AFFIX_STATUS_NONE","AFFIX_STATUS_PREPARE","Affix","forwardRef","props","ref","_a","style","offsetTop","offsetBottom","prefixCls","className","rootClassName","children","target","onChange","onTestUpdatePosition","restProps","getPrefixCls","getTargetContainer","useContext","affixPrefixCls","lastAffix","setLastAffix","useState","affixStyle","setAffixStyle","placeholderStyle","setPlaceholderStyle","status","useRef","prevTarget","prevListener","placeholderNodeRef","fixedNodeRef","timer","targetFunc","internalOffsetTop","undefined","measure","current","targetNode","newState","placeholderRect","top","left","width","height","targetRect","fixedTop","fixedBottom","position","bottom","prepareMeasure","process","env","NODE_ENV","updatePosition","lazyUpdatePosition","addListeners","listenerTarget","forEach","eventName","removeEventListener","addEventListener","removeListeners","clearTimeout","newTarget","cancel","useImperativeHandle","useEffect","setTimeout","wrapCSSVar","hashId","cssVarCls","rootCls","mergedCls","createElement","onResize","assign","displayName"],"mappings":"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","sourcesContent":["\"use client\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport React from 'react';\nimport classNames from 'classnames';\nimport ResizeObserver from 'rc-resize-observer';\nimport throttleByAnimationFrame from '../_util/throttleByAnimationFrame';\nimport { ConfigContext } from '../config-provider';\nimport useStyle from './style';\nimport { getFixedBottom, getFixedTop, getTargetRect } from './utils';\nconst TRIGGER_EVENTS = ['resize', 'scroll', 'touchstart', 'touchmove', 'touchend', 'pageshow', 'load'];\nfunction getDefaultTarget() {\n  return typeof window !== 'undefined' ? window : null;\n}\nconst AFFIX_STATUS_NONE = 0;\nconst AFFIX_STATUS_PREPARE = 1;\nconst Affix = /*#__PURE__*/React.forwardRef((props, ref) => {\n  var _a;\n  const {\n      style,\n      offsetTop,\n      offsetBottom,\n      prefixCls,\n      className,\n      rootClassName,\n      children,\n      target,\n      onChange,\n      onTestUpdatePosition\n    } = props,\n    restProps = __rest(props, [\"style\", \"offsetTop\", \"offsetBottom\", \"prefixCls\", \"className\", \"rootClassName\", \"children\", \"target\", \"onChange\", \"onTestUpdatePosition\"]);\n  const {\n    getPrefixCls,\n    getTargetContainer\n  } = React.useContext(ConfigContext);\n  const affixPrefixCls = getPrefixCls('affix', prefixCls);\n  const [lastAffix, setLastAffix] = React.useState(false);\n  const [affixStyle, setAffixStyle] = React.useState();\n  const [placeholderStyle, setPlaceholderStyle] = React.useState();\n  const status = React.useRef(AFFIX_STATUS_NONE);\n  const prevTarget = React.useRef(null);\n  const prevListener = React.useRef(null);\n  const placeholderNodeRef = React.useRef(null);\n  const fixedNodeRef = React.useRef(null);\n  const timer = React.useRef(null);\n  const targetFunc = (_a = target !== null && target !== void 0 ? target : getTargetContainer) !== null && _a !== void 0 ? _a : getDefaultTarget;\n  const internalOffsetTop = offsetBottom === undefined && offsetTop === undefined ? 0 : offsetTop;\n  // =================== Measure ===================\n  const measure = () => {\n    if (status.current !== AFFIX_STATUS_PREPARE || !fixedNodeRef.current || !placeholderNodeRef.current || !targetFunc) {\n      return;\n    }\n    const targetNode = targetFunc();\n    if (targetNode) {\n      const newState = {\n        status: AFFIX_STATUS_NONE\n      };\n      const placeholderRect = getTargetRect(placeholderNodeRef.current);\n      if (placeholderRect.top === 0 && placeholderRect.left === 0 && placeholderRect.width === 0 && placeholderRect.height === 0) {\n        return;\n      }\n      const targetRect = getTargetRect(targetNode);\n      const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n      const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n      if (fixedTop !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          top: fixedTop,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      } else if (fixedBottom !== undefined) {\n        newState.affixStyle = {\n          position: 'fixed',\n          bottom: fixedBottom,\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n        newState.placeholderStyle = {\n          width: placeholderRect.width,\n          height: placeholderRect.height\n        };\n      }\n      newState.lastAffix = !!newState.affixStyle;\n      if (lastAffix !== newState.lastAffix) {\n        onChange === null || onChange === void 0 ? void 0 : onChange(newState.lastAffix);\n      }\n      status.current = newState.status;\n      setAffixStyle(newState.affixStyle);\n      setPlaceholderStyle(newState.placeholderStyle);\n      setLastAffix(newState.lastAffix);\n    }\n  };\n  const prepareMeasure = () => {\n    status.current = AFFIX_STATUS_PREPARE;\n    measure();\n    if (process.env.NODE_ENV === 'test') {\n      onTestUpdatePosition === null || onTestUpdatePosition === void 0 ? void 0 : onTestUpdatePosition();\n    }\n  };\n  const updatePosition = throttleByAnimationFrame(() => {\n    prepareMeasure();\n  });\n  const lazyUpdatePosition = throttleByAnimationFrame(() => {\n    // Check position change before measure to make Safari smooth\n    if (targetFunc && affixStyle) {\n      const targetNode = targetFunc();\n      if (targetNode && placeholderNodeRef.current) {\n        const targetRect = getTargetRect(targetNode);\n        const placeholderRect = getTargetRect(placeholderNodeRef.current);\n        const fixedTop = getFixedTop(placeholderRect, targetRect, internalOffsetTop);\n        const fixedBottom = getFixedBottom(placeholderRect, targetRect, offsetBottom);\n        if (fixedTop !== undefined && affixStyle.top === fixedTop || fixedBottom !== undefined && affixStyle.bottom === fixedBottom) {\n          return;\n        }\n      }\n    }\n    // Directly call prepare measure since it's already throttled.\n    prepareMeasure();\n  });\n  const addListeners = () => {\n    const listenerTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    if (!listenerTarget) {\n      return;\n    }\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n      listenerTarget === null || listenerTarget === void 0 ? void 0 : listenerTarget.addEventListener(eventName, lazyUpdatePosition);\n    });\n    prevTarget.current = listenerTarget;\n    prevListener.current = lazyUpdatePosition;\n  };\n  const removeListeners = () => {\n    if (timer.current) {\n      clearTimeout(timer.current);\n      timer.current = null;\n    }\n    const newTarget = targetFunc === null || targetFunc === void 0 ? void 0 : targetFunc();\n    TRIGGER_EVENTS.forEach(eventName => {\n      var _a;\n      newTarget === null || newTarget === void 0 ? void 0 : newTarget.removeEventListener(eventName, lazyUpdatePosition);\n      if (prevListener.current) {\n        (_a = prevTarget.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, prevListener.current);\n      }\n    });\n    updatePosition.cancel();\n    lazyUpdatePosition.cancel();\n  };\n  React.useImperativeHandle(ref, () => ({\n    updatePosition\n  }));\n  // mount & unmount\n  React.useEffect(() => {\n    // [Legacy] Wait for parent component ref has its value.\n    // We should use target as directly element instead of function which makes element check hard.\n    timer.current = setTimeout(addListeners);\n    return () => removeListeners();\n  }, []);\n  React.useEffect(() => {\n    addListeners();\n    return () => removeListeners();\n  }, [target, affixStyle, lastAffix, offsetTop, offsetBottom]);\n  React.useEffect(() => {\n    updatePosition();\n  }, [target, offsetTop, offsetBottom]);\n  const [wrapCSSVar, hashId, cssVarCls] = useStyle(affixPrefixCls);\n  const rootCls = classNames(rootClassName, hashId, affixPrefixCls, cssVarCls);\n  const mergedCls = classNames({\n    [rootCls]: affixStyle\n  });\n  return wrapCSSVar(/*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, /*#__PURE__*/React.createElement(\"div\", Object.assign({\n    style: style,\n    className: className,\n    ref: placeholderNodeRef\n  }, restProps), affixStyle && /*#__PURE__*/React.createElement(\"div\", {\n    style: placeholderStyle,\n    \"aria-hidden\": \"true\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: mergedCls,\n    ref: fixedNodeRef,\n    style: affixStyle\n  }, /*#__PURE__*/React.createElement(ResizeObserver, {\n    onResize: updatePosition\n  }, children)))));\n});\nif (process.env.NODE_ENV !== 'production') {\n  Affix.displayName = 'Affix';\n}\nexport default Affix;"]},"metadata":{},"sourceType":"module"}