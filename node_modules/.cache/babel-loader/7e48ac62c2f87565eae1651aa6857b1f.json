{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nvar enableStatistic = process.env.NODE_ENV !== 'production' || typeof CSSINJS_STATISTIC !== 'undefined';\nvar recording = true;\n/**\n * This function will do as `Object.assign` in production. But will use Object.defineProperty:get to\n * pass all value access in development. To support statistic field usage with alias token.\n */\n\nexport function merge() {\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n  /* istanbul ignore next */\n\n\n  if (!enableStatistic) {\n    return Object.assign.apply(Object, [{}].concat(objs));\n  }\n\n  recording = false;\n  var ret = {};\n  objs.forEach(function (obj) {\n    if (_typeof(obj) !== 'object') {\n      return;\n    }\n\n    var keys = Object.keys(obj);\n    keys.forEach(function (key) {\n      Object.defineProperty(ret, key, {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          return obj[key];\n        }\n      });\n    });\n  });\n  recording = true;\n  return ret;\n}\n/** @internal Internal Usage. Not use in your production. */\n\nexport var statistic = {};\n/** @internal Internal Usage. Not use in your production. */\n\nexport var _statistic_build_ = {};\n/* istanbul ignore next */\n\nfunction noop() {}\n/** Statistic token usage case. Should use `merge` function if you do not want spread record. */\n\n\nvar statisticToken = function statisticToken(token) {\n  var tokenKeys;\n  var proxy = token;\n  var flush = noop;\n\n  if (enableStatistic && typeof Proxy !== 'undefined') {\n    tokenKeys = new Set();\n    proxy = new Proxy(token, {\n      get: function get(obj, prop) {\n        if (recording) {\n          var _tokenKeys;\n\n          (_tokenKeys = tokenKeys) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);\n        }\n\n        return obj[prop];\n      }\n    });\n\n    flush = function flush(componentName, componentToken) {\n      var _statistic$componentN;\n\n      statistic[componentName] = {\n        global: Array.from(tokenKeys),\n        component: _objectSpread(_objectSpread({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)\n      };\n    };\n  }\n\n  return {\n    token: proxy,\n    keys: tokenKeys,\n    flush: flush\n  };\n};\n\nexport default statisticToken;","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/@ant-design/cssinjs-utils/es/util/statistic.js"],"names":["_objectSpread","_typeof","enableStatistic","process","env","NODE_ENV","CSSINJS_STATISTIC","recording","merge","_len","arguments","length","objs","Array","_key","Object","assign","apply","concat","ret","forEach","obj","keys","key","defineProperty","configurable","enumerable","get","statistic","_statistic_build_","noop","statisticToken","token","tokenKeys","proxy","flush","Proxy","Set","prop","_tokenKeys","add","componentName","componentToken","_statistic$componentN","global","from","component"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _typeof from \"@babel/runtime/helpers/esm/typeof\";\nvar enableStatistic = process.env.NODE_ENV !== 'production' || typeof CSSINJS_STATISTIC !== 'undefined';\nvar recording = true;\n\n/**\n * This function will do as `Object.assign` in production. But will use Object.defineProperty:get to\n * pass all value access in development. To support statistic field usage with alias token.\n */\nexport function merge() {\n  for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {\n    objs[_key] = arguments[_key];\n  }\n  /* istanbul ignore next */\n  if (!enableStatistic) {\n    return Object.assign.apply(Object, [{}].concat(objs));\n  }\n  recording = false;\n  var ret = {};\n  objs.forEach(function (obj) {\n    if (_typeof(obj) !== 'object') {\n      return;\n    }\n    var keys = Object.keys(obj);\n    keys.forEach(function (key) {\n      Object.defineProperty(ret, key, {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n          return obj[key];\n        }\n      });\n    });\n  });\n  recording = true;\n  return ret;\n}\n\n/** @internal Internal Usage. Not use in your production. */\nexport var statistic = {};\n\n/** @internal Internal Usage. Not use in your production. */\nexport var _statistic_build_ = {};\n\n/* istanbul ignore next */\nfunction noop() {}\n\n/** Statistic token usage case. Should use `merge` function if you do not want spread record. */\nvar statisticToken = function statisticToken(token) {\n  var tokenKeys;\n  var proxy = token;\n  var flush = noop;\n  if (enableStatistic && typeof Proxy !== 'undefined') {\n    tokenKeys = new Set();\n    proxy = new Proxy(token, {\n      get: function get(obj, prop) {\n        if (recording) {\n          var _tokenKeys;\n          (_tokenKeys = tokenKeys) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);\n        }\n        return obj[prop];\n      }\n    });\n    flush = function flush(componentName, componentToken) {\n      var _statistic$componentN;\n      statistic[componentName] = {\n        global: Array.from(tokenKeys),\n        component: _objectSpread(_objectSpread({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)\n      };\n    };\n  }\n  return {\n    token: proxy,\n    keys: tokenKeys,\n    flush: flush\n  };\n};\nexport default statisticToken;"]},"metadata":{},"sourceType":"module"}