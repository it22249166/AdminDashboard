{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport React from 'react';\nvar BEAT_LIMIT = 1000 * 60 * 10;\n/**\n * A helper class to map keys to values.\n * It supports both primitive keys and object keys.\n */\n\nvar ArrayKeyMap = /*#__PURE__*/function () {\n  function ArrayKeyMap() {\n    _classCallCheck(this, ArrayKeyMap);\n\n    _defineProperty(this, \"map\", new Map()); // Use WeakMap to avoid memory leak\n\n\n    _defineProperty(this, \"objectIDMap\", new WeakMap());\n\n    _defineProperty(this, \"nextID\", 0);\n\n    _defineProperty(this, \"lastAccessBeat\", new Map()); // We will clean up the cache when reach the limit\n\n\n    _defineProperty(this, \"accessBeat\", 0);\n  }\n\n  _createClass(ArrayKeyMap, [{\n    key: \"set\",\n    value: function set(keys, value) {\n      // New set will trigger clear\n      this.clear(); // Set logic\n\n      var compositeKey = this.getCompositeKey(keys);\n      this.map.set(compositeKey, value);\n      this.lastAccessBeat.set(compositeKey, Date.now());\n    }\n  }, {\n    key: \"get\",\n    value: function get(keys) {\n      var compositeKey = this.getCompositeKey(keys);\n      var cache = this.map.get(compositeKey);\n      this.lastAccessBeat.set(compositeKey, Date.now());\n      this.accessBeat += 1;\n      return cache;\n    }\n  }, {\n    key: \"getCompositeKey\",\n    value: function getCompositeKey(keys) {\n      var _this = this;\n\n      var ids = keys.map(function (key) {\n        if (key && _typeof(key) === 'object') {\n          return \"obj_\".concat(_this.getObjectID(key));\n        }\n\n        return \"\".concat(_typeof(key), \"_\").concat(key);\n      });\n      return ids.join('|');\n    }\n  }, {\n    key: \"getObjectID\",\n    value: function getObjectID(obj) {\n      if (this.objectIDMap.has(obj)) {\n        return this.objectIDMap.get(obj);\n      }\n\n      var id = this.nextID;\n      this.objectIDMap.set(obj, id);\n      this.nextID += 1;\n      return id;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n\n      if (this.accessBeat > 10000) {\n        var now = Date.now();\n        this.lastAccessBeat.forEach(function (beat, key) {\n          if (now - beat > BEAT_LIMIT) {\n            _this2.map.delete(key);\n\n            _this2.lastAccessBeat.delete(key);\n          }\n        });\n        this.accessBeat = 0;\n      }\n    }\n  }]);\n\n  return ArrayKeyMap;\n}();\n\nvar uniqueMap = new ArrayKeyMap();\n/**\n * Like `useMemo`, but this hook result will be shared across all instances.\n */\n\nfunction useUniqueMemo(memoFn, deps) {\n  return React.useMemo(function () {\n    var cachedValue = uniqueMap.get(deps);\n\n    if (cachedValue) {\n      return cachedValue;\n    }\n\n    var newValue = memoFn();\n    uniqueMap.set(deps, newValue);\n    return newValue;\n  }, deps);\n}\n\nexport default useUniqueMemo;","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/@ant-design/cssinjs-utils/es/_util/hooks/useUniqueMemo.js"],"names":["_typeof","_classCallCheck","_createClass","_defineProperty","React","BEAT_LIMIT","ArrayKeyMap","Map","WeakMap","key","value","set","keys","clear","compositeKey","getCompositeKey","map","lastAccessBeat","Date","now","get","cache","accessBeat","_this","ids","concat","getObjectID","join","obj","objectIDMap","has","id","nextID","_this2","forEach","beat","delete","uniqueMap","useUniqueMemo","memoFn","deps","useMemo","cachedValue","newValue"],"mappings":"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","sourcesContent":["import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport React from 'react';\nvar BEAT_LIMIT = 1000 * 60 * 10;\n\n/**\n * A helper class to map keys to values.\n * It supports both primitive keys and object keys.\n */\nvar ArrayKeyMap = /*#__PURE__*/function () {\n  function ArrayKeyMap() {\n    _classCallCheck(this, ArrayKeyMap);\n    _defineProperty(this, \"map\", new Map());\n    // Use WeakMap to avoid memory leak\n    _defineProperty(this, \"objectIDMap\", new WeakMap());\n    _defineProperty(this, \"nextID\", 0);\n    _defineProperty(this, \"lastAccessBeat\", new Map());\n    // We will clean up the cache when reach the limit\n    _defineProperty(this, \"accessBeat\", 0);\n  }\n  _createClass(ArrayKeyMap, [{\n    key: \"set\",\n    value: function set(keys, value) {\n      // New set will trigger clear\n      this.clear();\n\n      // Set logic\n      var compositeKey = this.getCompositeKey(keys);\n      this.map.set(compositeKey, value);\n      this.lastAccessBeat.set(compositeKey, Date.now());\n    }\n  }, {\n    key: \"get\",\n    value: function get(keys) {\n      var compositeKey = this.getCompositeKey(keys);\n      var cache = this.map.get(compositeKey);\n      this.lastAccessBeat.set(compositeKey, Date.now());\n      this.accessBeat += 1;\n      return cache;\n    }\n  }, {\n    key: \"getCompositeKey\",\n    value: function getCompositeKey(keys) {\n      var _this = this;\n      var ids = keys.map(function (key) {\n        if (key && _typeof(key) === 'object') {\n          return \"obj_\".concat(_this.getObjectID(key));\n        }\n        return \"\".concat(_typeof(key), \"_\").concat(key);\n      });\n      return ids.join('|');\n    }\n  }, {\n    key: \"getObjectID\",\n    value: function getObjectID(obj) {\n      if (this.objectIDMap.has(obj)) {\n        return this.objectIDMap.get(obj);\n      }\n      var id = this.nextID;\n      this.objectIDMap.set(obj, id);\n      this.nextID += 1;\n      return id;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this2 = this;\n      if (this.accessBeat > 10000) {\n        var now = Date.now();\n        this.lastAccessBeat.forEach(function (beat, key) {\n          if (now - beat > BEAT_LIMIT) {\n            _this2.map.delete(key);\n            _this2.lastAccessBeat.delete(key);\n          }\n        });\n        this.accessBeat = 0;\n      }\n    }\n  }]);\n  return ArrayKeyMap;\n}();\nvar uniqueMap = new ArrayKeyMap();\n\n/**\n * Like `useMemo`, but this hook result will be shared across all instances.\n */\nfunction useUniqueMemo(memoFn, deps) {\n  return React.useMemo(function () {\n    var cachedValue = uniqueMap.get(deps);\n    if (cachedValue) {\n      return cachedValue;\n    }\n    var newValue = memoFn();\n    uniqueMap.set(deps, newValue);\n    return newValue;\n  }, deps);\n}\nexport default useUniqueMemo;"]},"metadata":{},"sourceType":"module"}