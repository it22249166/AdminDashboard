{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useRef, useState } from 'react';\n\nfunction getPosition(e) {\n  var obj = 'touches' in e ? e.touches[0] : e;\n  var scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;\n  var scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;\n  return {\n    pageX: obj.pageX - scrollXOffset,\n    pageY: obj.pageY - scrollYOffset\n  };\n}\n\nfunction useColorDrag(props) {\n  var targetRef = props.targetRef,\n      containerRef = props.containerRef,\n      direction = props.direction,\n      onDragChange = props.onDragChange,\n      onDragChangeComplete = props.onDragChangeComplete,\n      calculate = props.calculate,\n      color = props.color,\n      disabledDrag = props.disabledDrag;\n\n  var _useState = useState({\n    x: 0,\n    y: 0\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      offsetValue = _useState2[0],\n      setOffsetValue = _useState2[1];\n\n  var mouseMoveRef = useRef(null);\n  var mouseUpRef = useRef(null); // Always get position from `color`\n\n  useEffect(function () {\n    setOffsetValue(calculate());\n  }, [color]);\n  useEffect(function () {\n    return function () {\n      document.removeEventListener('mousemove', mouseMoveRef.current);\n      document.removeEventListener('mouseup', mouseUpRef.current);\n      document.removeEventListener('touchmove', mouseMoveRef.current);\n      document.removeEventListener('touchend', mouseUpRef.current);\n      mouseMoveRef.current = null;\n      mouseUpRef.current = null;\n    };\n  }, []);\n\n  var updateOffset = function updateOffset(e) {\n    var _getPosition = getPosition(e),\n        pageX = _getPosition.pageX,\n        pageY = _getPosition.pageY;\n\n    var _containerRef$current = containerRef.current.getBoundingClientRect(),\n        rectX = _containerRef$current.x,\n        rectY = _containerRef$current.y,\n        width = _containerRef$current.width,\n        height = _containerRef$current.height;\n\n    var _targetRef$current$ge = targetRef.current.getBoundingClientRect(),\n        targetWidth = _targetRef$current$ge.width,\n        targetHeight = _targetRef$current$ge.height;\n\n    var centerOffsetX = targetWidth / 2;\n    var centerOffsetY = targetHeight / 2;\n    var offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;\n    var offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;\n    var calcOffset = {\n      x: offsetX,\n      y: direction === 'x' ? offsetValue.y : offsetY\n    }; // Exclusion of boundary cases\n\n    if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {\n      return false;\n    }\n\n    onDragChange === null || onDragChange === void 0 || onDragChange(calcOffset);\n  };\n\n  var onDragMove = function onDragMove(e) {\n    e.preventDefault();\n    updateOffset(e);\n  };\n\n  var onDragStop = function onDragStop(e) {\n    e.preventDefault();\n    document.removeEventListener('mousemove', mouseMoveRef.current);\n    document.removeEventListener('mouseup', mouseUpRef.current);\n    document.removeEventListener('touchmove', mouseMoveRef.current);\n    document.removeEventListener('touchend', mouseUpRef.current);\n    mouseMoveRef.current = null;\n    mouseUpRef.current = null;\n    onDragChangeComplete === null || onDragChangeComplete === void 0 || onDragChangeComplete();\n  };\n\n  var onDragStart = function onDragStart(e) {\n    // https://github.com/ant-design/ant-design/issues/43529\n    document.removeEventListener('mousemove', mouseMoveRef.current);\n    document.removeEventListener('mouseup', mouseUpRef.current);\n\n    if (disabledDrag) {\n      return;\n    }\n\n    updateOffset(e);\n    document.addEventListener('mousemove', onDragMove);\n    document.addEventListener('mouseup', onDragStop);\n    document.addEventListener('touchmove', onDragMove);\n    document.addEventListener('touchend', onDragStop);\n    mouseMoveRef.current = onDragMove;\n    mouseUpRef.current = onDragStop;\n  };\n\n  return [offsetValue, onDragStart];\n}\n\nexport default useColorDrag;","map":{"version":3,"sources":["/Users/malith_bandara/Desktop/AdminDashboard/node_modules/@rc-component/color-picker/es/hooks/useColorDrag.js"],"names":["_slicedToArray","useEffect","useRef","useState","getPosition","e","obj","touches","scrollXOffset","document","documentElement","scrollLeft","body","window","pageXOffset","scrollYOffset","scrollTop","pageYOffset","pageX","pageY","useColorDrag","props","targetRef","containerRef","direction","onDragChange","onDragChangeComplete","calculate","color","disabledDrag","_useState","x","y","_useState2","offsetValue","setOffsetValue","mouseMoveRef","mouseUpRef","removeEventListener","current","updateOffset","_getPosition","_containerRef$current","getBoundingClientRect","rectX","rectY","width","height","_targetRef$current$ge","targetWidth","targetHeight","centerOffsetX","centerOffsetY","offsetX","Math","max","min","offsetY","calcOffset","onDragMove","preventDefault","onDragStop","onDragStart","addEventListener"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useEffect, useRef, useState } from 'react';\nfunction getPosition(e) {\n  var obj = 'touches' in e ? e.touches[0] : e;\n  var scrollXOffset = document.documentElement.scrollLeft || document.body.scrollLeft || window.pageXOffset;\n  var scrollYOffset = document.documentElement.scrollTop || document.body.scrollTop || window.pageYOffset;\n  return {\n    pageX: obj.pageX - scrollXOffset,\n    pageY: obj.pageY - scrollYOffset\n  };\n}\nfunction useColorDrag(props) {\n  var targetRef = props.targetRef,\n    containerRef = props.containerRef,\n    direction = props.direction,\n    onDragChange = props.onDragChange,\n    onDragChangeComplete = props.onDragChangeComplete,\n    calculate = props.calculate,\n    color = props.color,\n    disabledDrag = props.disabledDrag;\n  var _useState = useState({\n      x: 0,\n      y: 0\n    }),\n    _useState2 = _slicedToArray(_useState, 2),\n    offsetValue = _useState2[0],\n    setOffsetValue = _useState2[1];\n  var mouseMoveRef = useRef(null);\n  var mouseUpRef = useRef(null);\n\n  // Always get position from `color`\n  useEffect(function () {\n    setOffsetValue(calculate());\n  }, [color]);\n  useEffect(function () {\n    return function () {\n      document.removeEventListener('mousemove', mouseMoveRef.current);\n      document.removeEventListener('mouseup', mouseUpRef.current);\n      document.removeEventListener('touchmove', mouseMoveRef.current);\n      document.removeEventListener('touchend', mouseUpRef.current);\n      mouseMoveRef.current = null;\n      mouseUpRef.current = null;\n    };\n  }, []);\n  var updateOffset = function updateOffset(e) {\n    var _getPosition = getPosition(e),\n      pageX = _getPosition.pageX,\n      pageY = _getPosition.pageY;\n    var _containerRef$current = containerRef.current.getBoundingClientRect(),\n      rectX = _containerRef$current.x,\n      rectY = _containerRef$current.y,\n      width = _containerRef$current.width,\n      height = _containerRef$current.height;\n    var _targetRef$current$ge = targetRef.current.getBoundingClientRect(),\n      targetWidth = _targetRef$current$ge.width,\n      targetHeight = _targetRef$current$ge.height;\n    var centerOffsetX = targetWidth / 2;\n    var centerOffsetY = targetHeight / 2;\n    var offsetX = Math.max(0, Math.min(pageX - rectX, width)) - centerOffsetX;\n    var offsetY = Math.max(0, Math.min(pageY - rectY, height)) - centerOffsetY;\n    var calcOffset = {\n      x: offsetX,\n      y: direction === 'x' ? offsetValue.y : offsetY\n    };\n\n    // Exclusion of boundary cases\n    if (targetWidth === 0 && targetHeight === 0 || targetWidth !== targetHeight) {\n      return false;\n    }\n    onDragChange === null || onDragChange === void 0 || onDragChange(calcOffset);\n  };\n  var onDragMove = function onDragMove(e) {\n    e.preventDefault();\n    updateOffset(e);\n  };\n  var onDragStop = function onDragStop(e) {\n    e.preventDefault();\n    document.removeEventListener('mousemove', mouseMoveRef.current);\n    document.removeEventListener('mouseup', mouseUpRef.current);\n    document.removeEventListener('touchmove', mouseMoveRef.current);\n    document.removeEventListener('touchend', mouseUpRef.current);\n    mouseMoveRef.current = null;\n    mouseUpRef.current = null;\n    onDragChangeComplete === null || onDragChangeComplete === void 0 || onDragChangeComplete();\n  };\n  var onDragStart = function onDragStart(e) {\n    // https://github.com/ant-design/ant-design/issues/43529\n    document.removeEventListener('mousemove', mouseMoveRef.current);\n    document.removeEventListener('mouseup', mouseUpRef.current);\n    if (disabledDrag) {\n      return;\n    }\n    updateOffset(e);\n    document.addEventListener('mousemove', onDragMove);\n    document.addEventListener('mouseup', onDragStop);\n    document.addEventListener('touchmove', onDragMove);\n    document.addEventListener('touchend', onDragStop);\n    mouseMoveRef.current = onDragMove;\n    mouseUpRef.current = onDragStop;\n  };\n  return [offsetValue, onDragStart];\n}\nexport default useColorDrag;"]},"metadata":{},"sourceType":"module"}